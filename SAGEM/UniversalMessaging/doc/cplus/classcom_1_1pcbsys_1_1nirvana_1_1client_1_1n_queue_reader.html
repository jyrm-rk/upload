<!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>com::pcbsys::nirvana::client::nQueueReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="nirvana.css" />
</head>
<body>
<div id="topbar">
<a href="http://www.universalmessaging.org/"><img id="logo" border="0" src="logo.png"/></a>
</div>
<div class="wrapper">
<div id="main">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecom.html">com</a></li><li class="navelem"><b>pcbsys</b></li><li class="navelem"><b>nirvana</b></li><li class="navelem"><a class="el" href="namespacecom_1_1pcbsys_1_1nirvana_1_1client.html">client</a></li><li class="navelem"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html">nQueueReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">com::pcbsys::nirvana::client::nQueueReader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is the base class for all Queue Readers and provides a generic reader interface.  
 <a href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#details">More...</a></p>

<p><code>#include &lt;nQueueReader.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for com::pcbsys::nirvana::client::nQueueReader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.png" usemap="#com::pcbsys::nirvana::client::nQueueReader_map" alt=""/>
  <map id="com::pcbsys::nirvana::client::nQueueReader_map" name="com::pcbsys::nirvana::client::nQueueReader_map">
<area href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_async_reader.html" title="This Reader enables the client to receive all events asynchronously. " alt="com::pcbsys::nirvana::client::nQueueAsyncReader" shape="rect" coords="0,56,360,80"/>
<area href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_sync_reader.html" title="This class provides the client with a synchronous interface into a Nirvana Queue. ..." alt="com::pcbsys::nirvana::client::nQueueSyncReader" shape="rect" coords="370,56,730,80"/>
<area href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_async_transaction_reader.html" title="This Reader enables the client to receive all events asynchronously. " alt="com::pcbsys::nirvana::client::nQueueAsyncTransactionReader" shape="rect" coords="0,112,360,136"/>
<area href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_sync_transaction_reader.html" title="This reader provides a synchronous queue reader model. " alt="com::pcbsys::nirvana::client::nQueueSyncTransactionReader" shape="rect" coords="370,112,730,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa699ba8078c3ddc6fa0ddf309dc135d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa699ba8078c3ddc6fa0ddf309dc135d6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#aa699ba8078c3ddc6fa0ddf309dc135d6">close</a> ()=0</td></tr>
<tr class="memdesc:aa699ba8078c3ddc6fa0ddf309dc135d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the subscription, and notify the server. <br/></td></tr>
<tr class="separator:aa699ba8078c3ddc6fa0ddf309dc135d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed36387812089be870b8402d5de068"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71ed36387812089be870b8402d5de068"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a71ed36387812089be870b8402d5de068">closeLocally</a> ()=0</td></tr>
<tr class="memdesc:a71ed36387812089be870b8402d5de068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the subscription, but do not notify the server. <br/></td></tr>
<tr class="separator:a71ed36387812089be870b8402d5de068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8457de7c34bbb31f121d319aa530093c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a8457de7c34bbb31f121d319aa530093c">destroyReader</a> ()</td></tr>
<tr class="memdesc:a8457de7c34bbb31f121d319aa530093c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call will release any outstanding resources on the server and close the reader.  <a href="#a8457de7c34bbb31f121d319aa530093c">More...</a><br/></td></tr>
<tr class="separator:a8457de7c34bbb31f121d319aa530093c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1e6cabbf6c543f853f739cdea05a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a4c1e6cabbf6c543f853f739cdea05a6f">destroyReaderLocally</a> ()</td></tr>
<tr class="memdesc:a4c1e6cabbf6c543f853f739cdea05a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call will close local reader resources but remain subscribed at the server Any future calls to this object will work unless <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a8457de7c34bbb31f121d319aa530093c" title="This call will release any outstanding resources on the server and close the reader. ">destroyReader()</a> is called.  <a href="#a4c1e6cabbf6c543f853f739cdea05a6f">More...</a><br/></td></tr>
<tr class="separator:a4c1e6cabbf6c543f853f739cdea05a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a32572eda1a01b2bca031ad017f79cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a1a32572eda1a01b2bca031ad017f79cd">hasConsumedEvents</a> ()</td></tr>
<tr class="memdesc:a1a32572eda1a01b2bca031ad017f79cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to see whether the reader has consumed any events.  <a href="#a1a32572eda1a01b2bca031ad017f79cd">More...</a><br/></td></tr>
<tr class="separator:a1a32572eda1a01b2bca031ad017f79cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880ac550fcb0f50124b79ae7e8452a46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a880ac550fcb0f50124b79ae7e8452a46">isClosed</a> ()</td></tr>
<tr class="memdesc:a880ac550fcb0f50124b79ae7e8452a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a reader is closed, the physical subscription is closed at the server.  <a href="#a880ac550fcb0f50124b79ae7e8452a46">More...</a><br/></td></tr>
<tr class="separator:a880ac550fcb0f50124b79ae7e8452a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bf10f85b693e81fdefab92197b34c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a22bf10f85b693e81fdefab92197b34c7">isClosedLocally</a> ()</td></tr>
<tr class="memdesc:a22bf10f85b693e81fdefab92197b34c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader can be closed, but the physical subscription queue is not closed at the server.  <a href="#a22bf10f85b693e81fdefab92197b34c7">More...</a><br/></td></tr>
<tr class="separator:a22bf10f85b693e81fdefab92197b34c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23be367c7d01d2631a43da846e1495dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_consume_event.html">nConsumeEvent</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a23be367c7d01d2631a43da846e1495dc">peek</a> (<a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_peek_context.html">nQueuePeekContext</a> *pContext, int &amp;nEvent)</td></tr>
<tr class="memdesc:a23be367c7d01d2631a43da846e1495dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non destructive read.  <a href="#a23be367c7d01d2631a43da846e1495dc">More...</a><br/></td></tr>
<tr class="separator:a23be367c7d01d2631a43da846e1495dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4f7b101707cf8fb223e7efa0cc5cb80b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_peek_context.html">nQueuePeekContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a4f7b101707cf8fb223e7efa0cc5cb80b">createContext</a> (int windowSize=0, const std::string &amp;selector=&quot;&quot;)</td></tr>
<tr class="memdesc:a4f7b101707cf8fb223e7efa0cc5cb80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Queue Peek Context, which is used to traverse the queue.  <a href="#a4f7b101707cf8fb223e7efa0cc5cb80b">More...</a><br/></td></tr>
<tr class="separator:a4f7b101707cf8fb223e7efa0cc5cb80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a97cca97e1bcda6e7477c31ad652140b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a97cca97e1bcda6e7477c31ad652140b6">nQueueReader</a> (<a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue.html">nQueue</a> *pQueue, <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader_context.html">nQueueReaderContext</a> *pContext)</td></tr>
<tr class="memdesc:a97cca97e1bcda6e7477c31ad652140b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reader for the specified queue using the given reader context. The reader will have its reader unique ID assigned implicitly.  <a href="#a97cca97e1bcda6e7477c31ad652140b6">More...</a><br/></td></tr>
<tr class="separator:a97cca97e1bcda6e7477c31ad652140b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4573823c6fa90ac10fc43c06e96955"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a4b4573823c6fa90ac10fc43c06e96955">nQueueReader</a> (<a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue.html">nQueue</a> *pQueue, <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader_context.html">nQueueReaderContext</a> *pContext, longlong readerUniqueId)</td></tr>
<tr class="memdesc:a4b4573823c6fa90ac10fc43c06e96955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reader for the specified queue using the given reader context and reader unique identifier. Note: This constructor must only be used for asynchronous readers, which require special reader ID assignment, for all other cases use the constructor which implicitly assigns the reader unique identifier.  <a href="#a4b4573823c6fa90ac10fc43c06e96955">More...</a><br/></td></tr>
<tr class="separator:a4b4573823c6fa90ac10fc43c06e96955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6ed895026a458e8106003fc85392c629"><td class="memItemLeft" align="right" valign="top">longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a6ed895026a458e8106003fc85392c629">m_readerUniqueId</a></td></tr>
<tr class="memdesc:a6ed895026a458e8106003fc85392c629"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identifier that uniquely identifies the reader which performs this queue operation within the session. This will be paired with the connection id to uniquely identify the reader within the Universal Messaging server. Note: This should be considered final, it must be set during reader creation and not modified afterwards.  <a href="#a6ed895026a458e8106003fc85392c629">More...</a><br/></td></tr>
<tr class="separator:a6ed895026a458e8106003fc85392c629"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is the base class for all Queue Readers and provides a generic reader interface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97cca97e1bcda6e7477c31ad652140b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">com::pcbsys::nirvana::client::nQueueReader::nQueueReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue.html">nQueue</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader_context.html">nQueueReaderContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a reader for the specified queue using the given reader context. The reader will have its reader unique ID assigned implicitly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue to create reader for. Must not be null.</td></tr>
    <tr><td class="paramname">pContext</td><td>The reader context to use</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b4573823c6fa90ac10fc43c06e96955"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">com::pcbsys::nirvana::client::nQueueReader::nQueueReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue.html">nQueue</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader_context.html">nQueueReaderContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">longlong&#160;</td>
          <td class="paramname"><em>readerUniqueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a reader for the specified queue using the given reader context and reader unique identifier. Note: This constructor must only be used for asynchronous readers, which require special reader ID assignment, for all other cases use the constructor which implicitly assigns the reader unique identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue to create reader for.</td></tr>
    <tr><td class="paramname">pContext</td><td>The reader context to use.</td></tr>
    <tr><td class="paramname">readerUniqueId</td><td>The reader unique identifier to use for this reader.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4f7b101707cf8fb223e7efa0cc5cb80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_peek_context.html">nQueuePeekContext</a>* com::pcbsys::nirvana::client::nQueueReader::createContext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>selector</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Queue Peek Context, which is used to traverse the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowSize</td><td>The size of the window over the queue to uses </td></tr>
    <tr><td class="paramname">selector</td><td>A message selector to be applied on the events received </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_peek_context.html" title="Provides a context when peeking on the queue. ">nQueuePeekContext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8457de7c34bbb31f121d319aa530093c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nQueueReader::destroyReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This call will release any outstanding resources on the server and close the reader. </p>
<p>Any future calls to this object will result in an <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_state_exception.html" title="This exception is thrown if a Channel or Queue is in an illegal state for specific functionality to b...">nIllegalStateException</a> being raised.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_unexpected_response_exception.html" title="The server responded with an event that the client did not expect. ">nUnexpectedResponseException</a></td><td>if the server returns a response that was not expected </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session_not_connected_exception.html" title="The current nSession is not currently connected. ">nSessionNotConnectedException</a></td><td>if the session is currently not connected to the server </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a></td><td>if the request did not receive a response within the timeout period </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session_paused_exception.html" title="This exception is thrown when an attempt is made by the client to make a request to the server...">nSessionPausedException</a></td><td>The session is currently paused </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c1e6cabbf6c543f853f739cdea05a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nQueueReader::destroyReaderLocally </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This call will close local reader resources but remain subscribed at the server Any future calls to this object will work unless <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_reader.html#a8457de7c34bbb31f121d319aa530093c" title="This call will release any outstanding resources on the server and close the reader. ">destroyReader()</a> is called. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_unexpected_response_exception.html" title="The server responded with an event that the client did not expect. ">nUnexpectedResponseException</a></td><td>if the server returns a response that was not expected </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session_not_connected_exception.html" title="The current nSession is not currently connected. ">nSessionNotConnectedException</a></td><td>if the session is currently not connected to the server </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a></td><td>if the request did not receive a response within the timeout period </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a32572eda1a01b2bca031ad017f79cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nQueueReader::hasConsumedEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to see whether the reader has consumed any events. </p>
<p>For transactional readers, this is reset every time commit or rollback is called.</p>
<dl class="section return"><dt>Returns</dt><dd>true if any events have been consumed by the reader </dd></dl>

</div>
</div>
<a class="anchor" id="a880ac550fcb0f50124b79ae7e8452a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nQueueReader::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a reader is closed, the physical subscription is closed at the server. </p>
<p>For Transactional readers, a close will rollback to the last committed event.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the reader has been closed </dd></dl>

</div>
</div>
<a class="anchor" id="a22bf10f85b693e81fdefab92197b34c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nQueueReader::isClosedLocally </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reader can be closed, but the physical subscription queue is not closed at the server. </p>
<p>For Transactional readers, a local close will not rollback to the last committed event.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the reader has been closed locally but not at the server </dd></dl>

</div>
</div>
<a class="anchor" id="a23be367c7d01d2631a43da846e1495dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_consume_event.html">nConsumeEvent</a>** com::pcbsys::nirvana::client::nQueueReader::peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_queue_peek_context.html">nQueuePeekContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non destructive read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pContext</td><td>Peek Context to use. Used when multiple calls required to traverse a queue </td></tr>
    <tr><td class="paramname">nEvent</td><td>the length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Array of events </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_security_exception.html" title="This class defines the security errors that can be thrown by using the nirvana client API...">nSecurityException</a></td><td>If the client is not authorized to perform this request </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_not_found_exception.html" title="The specified channel could not be located on the server. ">nChannelNotFoundException</a></td><td>The queue was not found </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session_not_connected_exception.html" title="The current nSession is not currently connected. ">nSessionNotConnectedException</a></td><td>Client is not currently connected to the server </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a></td><td>The server did not respond within the timeout </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_unexpected_response_exception.html" title="The server responded with an event that the client did not expect. ">nUnexpectedResponseException</a></td><td>The server responded with an unexpected response </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html" title="This class defines the error that can be thrown by passing an illegal argument to any method of any c...">nIllegalArgumentException</a></td><td>Invalid parameters passed </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session_paused_exception.html" title="This exception is thrown when an attempt is made by the client to make a request to the server...">nSessionPausedException</a></td><td>The session is currently paused, please resume </td></tr>
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_state_exception.html" title="This exception is thrown if a Channel or Queue is in an illegal state for specific functionality to b...">nIllegalStateException</a></td><td>The operation could not complete because of a session/connection error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a6ed895026a458e8106003fc85392c629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">longlong com::pcbsys::nirvana::client::nQueueReader::m_readerUniqueId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An identifier that uniquely identifies the reader which performs this queue operation within the session. This will be paired with the connection id to uniquely identify the reader within the Universal Messaging server. Note: This should be considered final, it must be set during reader creation and not modified afterwards. </p>

</div>
</div>
</div><!-- contents -->
</div> <!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  --> <!-- end main -->
</div> <!-- end wrapper -->
<div id="footer">
<div>
Copyright &copy; 2020 Software AG, Darmstadt Germany
and/or Software AG USA, Inc., Reston, VA, United States of America,
and/or their licensors.
<br/>
</div>
</div> <!-- end footer -->
</body>
</html>
