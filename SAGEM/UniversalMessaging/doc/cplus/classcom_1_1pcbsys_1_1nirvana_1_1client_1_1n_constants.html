<!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>com::pcbsys::nirvana::client::nConstants Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="nirvana.css" />
</head>
<body>
<div id="topbar">
<a href="http://www.universalmessaging.org/"><img id="logo" border="0" src="logo.png"/></a>
</div>
<div class="wrapper">
<div id="main">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecom.html">com</a></li><li class="navelem"><b>pcbsys</b></li><li class="navelem"><b>nirvana</b></li><li class="navelem"><a class="el" href="namespacecom_1_1pcbsys_1_1nirvana_1_1client.html">client</a></li><li class="navelem"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html">nConstants</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">com::pcbsys::nirvana::client::nConstants Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is a container for the various constants that affect the behaviour of various Nirvana Client API calls.  
 <a href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#details">More...</a></p>

<p><code>#include &lt;nConstants.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a99b2ae226067dfdb8e0e563208c433fd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a99b2ae226067dfdb8e0e563208c433fd">attemptReconnectAfterAccessChange</a> ()</td></tr>
<tr class="memdesc:a99b2ae226067dfdb8e0e563208c433fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked.  <a href="#a99b2ae226067dfdb8e0e563208c433fd">More...</a><br/></td></tr>
<tr class="separator:a99b2ae226067dfdb8e0e563208c433fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfb6f7527cc8170d1b36c4ceda4cf6f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7dfb6f7527cc8170d1b36c4ceda4cf6f">attemptReconnectImmediately</a> ()</td></tr>
<tr class="memdesc:a7dfb6f7527cc8170d1b36c4ceda4cf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once.  <a href="#a7dfb6f7527cc8170d1b36c4ceda4cf6f">More...</a><br/></td></tr>
<tr class="separator:a7dfb6f7527cc8170d1b36c4ceda4cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0331ab895cc6486ce6aa0f841796c0f7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a0331ab895cc6486ce6aa0f841796c0f7">compareNoCase</a> (const std::string &amp;string1, const std::string &amp;string2)</td></tr>
<tr class="memdesc:a0331ab895cc6486ce6aa0f841796c0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 strings for equality.  <a href="#a0331ab895cc6486ce6aa0f841796c0f7">More...</a><br/></td></tr>
<tr class="separator:a0331ab895cc6486ce6aa0f841796c0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1546ebb17aee7adfc5e7dc5c74b62b"><td class="memItemLeft" align="right" valign="top">static longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ade1546ebb17aee7adfc5e7dc5c74b62b">currentTimeMillis</a> ()</td></tr>
<tr class="memdesc:ade1546ebb17aee7adfc5e7dc5c74b62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an Epoch Date in milliseconds representing the current system date / time.  <a href="#ade1546ebb17aee7adfc5e7dc5c74b62b">More...</a><br/></td></tr>
<tr class="separator:ade1546ebb17aee7adfc5e7dc5c74b62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2e48da8d3a7c575b12730da76c98c1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7c2e48da8d3a7c575b12730da76c98c1">decode</a> (unsigned char *pBuffer, int size, std::string &amp;str)</td></tr>
<tr class="memdesc:a7c2e48da8d3a7c575b12730da76c98c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the array into a string.  <a href="#a7c2e48da8d3a7c575b12730da76c98c1">More...</a><br/></td></tr>
<tr class="separator:a7c2e48da8d3a7c575b12730da76c98c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45250e13e795a190a5105011200017f8"><td class="memItemLeft" align="right" valign="top">static unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a45250e13e795a190a5105011200017f8">encode</a> (const std::string &amp;str, unsigned int &amp;size)</td></tr>
<tr class="memdesc:a45250e13e795a190a5105011200017f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the string into an array.  <a href="#a45250e13e795a190a5105011200017f8">More...</a><br/></td></tr>
<tr class="separator:a45250e13e795a190a5105011200017f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dab593aae84c210a173725590c0c01"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a28dab593aae84c210a173725590c0c01">getAccessWaitLimit</a> ()</td></tr>
<tr class="memdesc:a28dab593aae84c210a173725590c0c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue access wait time.  <a href="#a28dab593aae84c210a173725590c0c01">More...</a><br/></td></tr>
<tr class="separator:a28dab593aae84c210a173725590c0c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac212319bd7975f25c979993e68332618"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac212319bd7975f25c979993e68332618"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ac212319bd7975f25c979993e68332618">GetAlgorithm</a> ()</td></tr>
<tr class="memdesc:ac212319bd7975f25c979993e68332618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the configured algoritmgs to use for SSL. <br/></td></tr>
<tr class="separator:ac212319bd7975f25c979993e68332618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb4377a8f2bb820a66a87aa72ca62ac"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aacb4377a8f2bb820a66a87aa72ca62ac">getBlockLimit</a> ()</td></tr>
<tr class="memdesc:aacb4377a8f2bb820a66a87aa72ca62ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue block wait time.  <a href="#aacb4377a8f2bb820a66a87aa72ca62ac">More...</a><br/></td></tr>
<tr class="separator:aacb4377a8f2bb820a66a87aa72ca62ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad7efa3a393876a60013be02c57063a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ad7efa3a393876a60013be02c57063a"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7ad7efa3a393876a60013be02c57063a">GetCAPath</a> ()</td></tr>
<tr class="memdesc:a7ad7efa3a393876a60013be02c57063a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CA path. <br/></td></tr>
<tr class="separator:a7ad7efa3a393876a60013be02c57063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304c752a68e2ad3c0dca16612bb66f37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a304c752a68e2ad3c0dca16612bb66f37"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a304c752a68e2ad3c0dca16612bb66f37">GetCertificatePassword</a> ()</td></tr>
<tr class="memdesc:a304c752a68e2ad3c0dca16612bb66f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the certificate password for the SSL client certificate used for authentication. <br/></td></tr>
<tr class="separator:a304c752a68e2ad3c0dca16612bb66f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac445a9529a426f70d8de522395aa153e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac445a9529a426f70d8de522395aa153e"></a>
static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ac445a9529a426f70d8de522395aa153e">GetCertificatePath</a> ()</td></tr>
<tr class="memdesc:ac445a9529a426f70d8de522395aa153e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the certificate path used for SSL client authentication. <br/></td></tr>
<tr class="separator:ac445a9529a426f70d8de522395aa153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5042646be0acabbcfe64a646c65b3251"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a5042646be0acabbcfe64a646c65b3251">getClientBuildNumber</a> ()</td></tr>
<tr class="memdesc:a5042646be0acabbcfe64a646c65b3251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the client build number information.  <a href="#a5042646be0acabbcfe64a646c65b3251">More...</a><br/></td></tr>
<tr class="separator:a5042646be0acabbcfe64a646c65b3251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1852cbe18b2edc85ddfbc8af741762"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a2d1852cbe18b2edc85ddfbc8af741762">getConnectionBlockWeighting</a> ()</td></tr>
<tr class="memdesc:a2d1852cbe18b2edc85ddfbc8af741762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue block weighting.  <a href="#a2d1852cbe18b2edc85ddfbc8af741762">More...</a><br/></td></tr>
<tr class="separator:a2d1852cbe18b2edc85ddfbc8af741762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f0f9ae3e06892c4a624624228c34ab"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a45f0f9ae3e06892c4a624624228c34ab">getConnectionQueueHighWater</a> ()</td></tr>
<tr class="memdesc:a45f0f9ae3e06892c4a624624228c34ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue high watermark.  <a href="#a45f0f9ae3e06892c4a624624228c34ab">More...</a><br/></td></tr>
<tr class="separator:a45f0f9ae3e06892c4a624624228c34ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cb8a1ae7ae7f6d8fb563393589044c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a66cb8a1ae7ae7f6d8fb563393589044c">getConnectionQueueLowWater</a> ()</td></tr>
<tr class="memdesc:a66cb8a1ae7ae7f6d8fb563393589044c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue low watermark.  <a href="#a66cb8a1ae7ae7f6d8fb563393589044c">More...</a><br/></td></tr>
<tr class="separator:a66cb8a1ae7ae7f6d8fb563393589044c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb9c528c2ea3f56d743a0e134f38aca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aafb9c528c2ea3f56d743a0e134f38aca">getDataGroupQueueSize</a> ()</td></tr>
<tr class="separator:aafb9c528c2ea3f56d743a0e134f38aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd58665a3b55dd732579beb060713b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a06cd58665a3b55dd732579beb060713b">getEnabledPriorityQueues</a> ()</td></tr>
<tr class="memdesc:a06cd58665a3b55dd732579beb060713b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether priority queueing is enabled for this client.  <a href="#a06cd58665a3b55dd732579beb060713b">More...</a><br/></td></tr>
<tr class="separator:a06cd58665a3b55dd732579beb060713b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531a2e5500397ab21de5850800081b45"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a531a2e5500397ab21de5850800081b45">getEVENTWAIT</a> ()</td></tr>
<tr class="memdesc:a531a2e5500397ab21de5850800081b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm.  <a href="#a531a2e5500397ab21de5850800081b45">More...</a><br/></td></tr>
<tr class="separator:a531a2e5500397ab21de5850800081b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445da42709df623a1b1d35f8c9322e89"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a445da42709df623a1b1d35f8c9322e89">getInitialConnectionTimeout</a> ()</td></tr>
<tr class="memdesc:a445da42709df623a1b1d35f8c9322e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the current value for the Initial socket connect timeout.  <a href="#a445da42709df623a1b1d35f8c9322e89">More...</a><br/></td></tr>
<tr class="separator:a445da42709df623a1b1d35f8c9322e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034e4af93a6a0498d9ecc60e2abee1ba"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a034e4af93a6a0498d9ecc60e2abee1ba">getKeepAliveInterval</a> ()</td></tr>
<tr class="memdesc:a034e4af93a6a0498d9ecc60e2abee1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value in ms to wait before sending a Keep Alive.  <a href="#a034e4af93a6a0498d9ecc60e2abee1ba">More...</a><br/></td></tr>
<tr class="separator:a034e4af93a6a0498d9ecc60e2abee1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286e853c869b2ce8ba1e73f906092351"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a286e853c869b2ce8ba1e73f906092351">getPushWaitLimit</a> ()</td></tr>
<tr class="memdesc:a286e853c869b2ce8ba1e73f906092351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue push wait time.  <a href="#a286e853c869b2ce8ba1e73f906092351">More...</a><br/></td></tr>
<tr class="separator:a286e853c869b2ce8ba1e73f906092351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c06e7460aa52650b05d37f86d1913e9"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a5c06e7460aa52650b05d37f86d1913e9">getReconnectInterval</a> ()</td></tr>
<tr class="memdesc:a5c06e7460aa52650b05d37f86d1913e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately.  <a href="#a5c06e7460aa52650b05d37f86d1913e9">More...</a><br/></td></tr>
<tr class="separator:a5c06e7460aa52650b05d37f86d1913e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db9df01ef90c8f19c4d5ef64d29b599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0db9df01ef90c8f19c4d5ef64d29b599"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a0db9df01ef90c8f19c4d5ef64d29b599">GetRelaxedSSLVerification</a> ()</td></tr>
<tr class="memdesc:a0db9df01ef90c8f19c4d5ef64d29b599"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true then there will be no SSL certificate validation, this is not recommended for production and should only be used during debug. <br/></td></tr>
<tr class="separator:a0db9df01ef90c8f19c4d5ef64d29b599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72928faee5407879deefa7a59b9aa43d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a72928faee5407879deefa7a59b9aa43d">getSocketReceiveBufferSize</a> ()</td></tr>
<tr class="memdesc:a72928faee5407879deefa7a59b9aa43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inbound socket buffer size.  <a href="#a72928faee5407879deefa7a59b9aa43d">More...</a><br/></td></tr>
<tr class="separator:a72928faee5407879deefa7a59b9aa43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7180f93c14a4f848dbde045db5934c4c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7180f93c14a4f848dbde045db5934c4c">getSocketSendBufferSize</a> ()</td></tr>
<tr class="memdesc:a7180f93c14a4f848dbde045db5934c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outbound socket buffer size.  <a href="#a7180f93c14a4f848dbde045db5934c4c">More...</a><br/></td></tr>
<tr class="separator:a7180f93c14a4f848dbde045db5934c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc6b11b5bafeedb81fc6781481455c3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a1dc6b11b5bafeedb81fc6781481455c3">getSubHighWater</a> ()</td></tr>
<tr class="memdesc:a1dc6b11b5bafeedb81fc6781481455c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the subscriber queue high watermark.  <a href="#a1dc6b11b5bafeedb81fc6781481455c3">More...</a><br/></td></tr>
<tr class="separator:a1dc6b11b5bafeedb81fc6781481455c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872764b648ddb53011a3cf6fb9441182"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a872764b648ddb53011a3cf6fb9441182">getSubLowWater</a> ()</td></tr>
<tr class="memdesc:a872764b648ddb53011a3cf6fb9441182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the subscriber queue low watermark.  <a href="#a872764b648ddb53011a3cf6fb9441182">More...</a><br/></td></tr>
<tr class="separator:a872764b648ddb53011a3cf6fb9441182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcff84b9328d9afaed169c5f894a48ff"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#adcff84b9328d9afaed169c5f894a48ff">getWriteHandlerType</a> ()</td></tr>
<tr class="memdesc:adcff84b9328d9afaed169c5f894a48ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current write handling mode that the client is using.  <a href="#adcff84b9328d9afaed169c5f894a48ff">More...</a><br/></td></tr>
<tr class="separator:adcff84b9328d9afaed169c5f894a48ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a36242ba98577a5743d83723b39fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a36242ba98577a5743d83723b39fd6"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a21a36242ba98577a5743d83723b39fd6">honourThirdPartyCookies</a> ()</td></tr>
<tr class="memdesc:a21a36242ba98577a5743d83723b39fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the client will maintain third party cookies. <br/></td></tr>
<tr class="separator:a21a36242ba98577a5743d83723b39fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53702525d32692da7115863bb08e005"><td class="memItemLeft" align="right" valign="top">static time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ac53702525d32692da7115863bb08e005">milliToDateTime</a> (longlong millis)</td></tr>
<tr class="memdesc:ac53702525d32692da7115863bb08e005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts milliseconds (time since EPOCH) into a time object;.  <a href="#ac53702525d32692da7115863bb08e005">More...</a><br/></td></tr>
<tr class="separator:ac53702525d32692da7115863bb08e005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d011f1e4b86ffcc2d52326f4531cbd7"><td class="memItemLeft" align="right" valign="top">static longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a1d011f1e4b86ffcc2d52326f4531cbd7">nanoTime</a> ()</td></tr>
<tr class="memdesc:a1d011f1e4b86ffcc2d52326f4531cbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current time in nanoseconds.  <a href="#a1d011f1e4b86ffcc2d52326f4531cbd7">More...</a><br/></td></tr>
<tr class="separator:a1d011f1e4b86ffcc2d52326f4531cbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3a1cdaa7d15b16daf6aab453bfc636"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a4e3a1cdaa7d15b16daf6aab453bfc636">setAccessWaitLimit</a> (int p_accessWait)</td></tr>
<tr class="memdesc:a4e3a1cdaa7d15b16daf6aab453bfc636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue access wait time.  <a href="#a4e3a1cdaa7d15b16daf6aab453bfc636">More...</a><br/></td></tr>
<tr class="separator:a4e3a1cdaa7d15b16daf6aab453bfc636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59ef4a0bb9b393d3b78aaea78138859"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad59ef4a0bb9b393d3b78aaea78138859"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ad59ef4a0bb9b393d3b78aaea78138859">SetAlgorithm</a> (const std::string &amp;algorithm)</td></tr>
<tr class="memdesc:ad59ef4a0bb9b393d3b78aaea78138859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the configured algoritmgs to use for SSL. <br/></td></tr>
<tr class="separator:ad59ef4a0bb9b393d3b78aaea78138859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf19bac701097975b3ec25e6a7e92f3c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#acf19bac701097975b3ec25e6a7e92f3c">setBlockLimit</a> (int p_blockWait)</td></tr>
<tr class="memdesc:acf19bac701097975b3ec25e6a7e92f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue block wait time.  <a href="#acf19bac701097975b3ec25e6a7e92f3c">More...</a><br/></td></tr>
<tr class="separator:acf19bac701097975b3ec25e6a7e92f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527db54e0b7a81be75e36a6308713880"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a527db54e0b7a81be75e36a6308713880"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a527db54e0b7a81be75e36a6308713880">SetCAPath</a> (const std::string &amp;CAPath)</td></tr>
<tr class="memdesc:a527db54e0b7a81be75e36a6308713880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the path to the CA. <br/></td></tr>
<tr class="separator:a527db54e0b7a81be75e36a6308713880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485cc87a770a7734357d4e2387eb7560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a485cc87a770a7734357d4e2387eb7560"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a485cc87a770a7734357d4e2387eb7560">SetCertificatePassword</a> (const std::string &amp;certificatePassword)</td></tr>
<tr class="memdesc:a485cc87a770a7734357d4e2387eb7560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the password for the pem certificate used for SSL client authentication. <br/></td></tr>
<tr class="separator:a485cc87a770a7734357d4e2387eb7560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cadf54d1f7bb478580127ffba371cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68cadf54d1f7bb478580127ffba371cb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a68cadf54d1f7bb478580127ffba371cb">SetCertificatePath</a> (const std::string &amp;certificatePath)</td></tr>
<tr class="memdesc:a68cadf54d1f7bb478580127ffba371cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the path to the pem certificate used for SSL client authentication. <br/></td></tr>
<tr class="separator:a68cadf54d1f7bb478580127ffba371cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8310654ed7fb01288e2737d9374e5206"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8310654ed7fb01288e2737d9374e5206">setClientLogFile</a> (FILE *file)</td></tr>
<tr class="memdesc:a8310654ed7fb01288e2737d9374e5206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a file for the client log messages.  <a href="#a8310654ed7fb01288e2737d9374e5206">More...</a><br/></td></tr>
<tr class="separator:a8310654ed7fb01288e2737d9374e5206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e2741a3eca6e7fb5749f1b8e875e10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a38e2741a3eca6e7fb5749f1b8e875e10">setClientLogLevel</a> (int level)</td></tr>
<tr class="memdesc:a38e2741a3eca6e7fb5749f1b8e875e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the log level for the client.  <a href="#a38e2741a3eca6e7fb5749f1b8e875e10">More...</a><br/></td></tr>
<tr class="separator:a38e2741a3eca6e7fb5749f1b8e875e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99939c84155c8b02b7705c79dbf132a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af99939c84155c8b02b7705c79dbf132a">setConnectionBlockWeighting</a> (int blockWeighting)</td></tr>
<tr class="memdesc:af99939c84155c8b02b7705c79dbf132a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue block weighting.  <a href="#af99939c84155c8b02b7705c79dbf132a">More...</a><br/></td></tr>
<tr class="separator:af99939c84155c8b02b7705c79dbf132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42820332c03ae1b8ca8401f8bcc91da8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a42820332c03ae1b8ca8401f8bcc91da8">setConnectionQueueHighWater</a> (int high)</td></tr>
<tr class="memdesc:a42820332c03ae1b8ca8401f8bcc91da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue high watermark.  <a href="#a42820332c03ae1b8ca8401f8bcc91da8">More...</a><br/></td></tr>
<tr class="separator:a42820332c03ae1b8ca8401f8bcc91da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae594c828c3d3b11887de2a5b861e02ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ae594c828c3d3b11887de2a5b861e02ec">setConnectionQueueLowWater</a> (int low)</td></tr>
<tr class="memdesc:ae594c828c3d3b11887de2a5b861e02ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue low watermark.  <a href="#ae594c828c3d3b11887de2a5b861e02ec">More...</a><br/></td></tr>
<tr class="separator:ae594c828c3d3b11887de2a5b861e02ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01777835e33a2e7f5ebb105febefa3b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af01777835e33a2e7f5ebb105febefa3b">setDataGroupQueueSize</a> (int queueSize)</td></tr>
<tr class="memdesc:af01777835e33a2e7f5ebb105febefa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of events that are still to ve delivered to the client.  <a href="#af01777835e33a2e7f5ebb105febefa3b">More...</a><br/></td></tr>
<tr class="separator:af01777835e33a2e7f5ebb105febefa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe0c04afe85c345113672aa95e4ee22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8fe0c04afe85c345113672aa95e4ee22">setEnabledPriorityQueues</a> (bool enabled)</td></tr>
<tr class="memdesc:a8fe0c04afe85c345113672aa95e4ee22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the usage of priority queues for this client.  <a href="#a8fe0c04afe85c345113672aa95e4ee22">More...</a><br/></td></tr>
<tr class="separator:a8fe0c04afe85c345113672aa95e4ee22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074b7fc024537b046456928271708ff1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a074b7fc024537b046456928271708ff1">setEVENTWAIT</a> (long newval)</td></tr>
<tr class="memdesc:a074b7fc024537b046456928271708ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm.  <a href="#a074b7fc024537b046456928271708ff1">More...</a><br/></td></tr>
<tr class="separator:a074b7fc024537b046456928271708ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c4b27ca98ab24c4a1ce0107019d056"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a68c4b27ca98ab24c4a1ce0107019d056">setHonourThirdPartyCookies</a> (bool doHonour)</td></tr>
<tr class="memdesc:a68c4b27ca98ab24c4a1ce0107019d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">If honourThirdPartyCookies is set to true then the client will maintain any third party cookies.  <a href="#a68c4b27ca98ab24c4a1ce0107019d056">More...</a><br/></td></tr>
<tr class="separator:a68c4b27ca98ab24c4a1ce0107019d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3896983fa76017d6982f34458c9a4a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a6f3896983fa76017d6982f34458c9a4a">setInitialConnectionTimeout</a> (int timeout)</td></tr>
<tr class="memdesc:a6f3896983fa76017d6982f34458c9a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the current value for the Initial socket connect timeout.  <a href="#a6f3896983fa76017d6982f34458c9a4a">More...</a><br/></td></tr>
<tr class="separator:a6f3896983fa76017d6982f34458c9a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14235115402b660a556f3c3126d72d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ac14235115402b660a556f3c3126d72d0">setKeepAliveInterval</a> (long newVal)</td></tr>
<tr class="memdesc:ac14235115402b660a556f3c3126d72d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value in ms to wait before sending a Keep Alive.  <a href="#ac14235115402b660a556f3c3126d72d0">More...</a><br/></td></tr>
<tr class="separator:ac14235115402b660a556f3c3126d72d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb7701d25c1a77d8898c7e3e580aab7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8bb7701d25c1a77d8898c7e3e580aab7">setPermittedKeepAlivesMissed</a> (int kas)</td></tr>
<tr class="memdesc:a8bb7701d25c1a77d8898c7e3e580aab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of keep alives that the client can miss before closing the connection.  <a href="#a8bb7701d25c1a77d8898c7e3e580aab7">More...</a><br/></td></tr>
<tr class="separator:a8bb7701d25c1a77d8898c7e3e580aab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f69b91557c8e72d86ca1ff5e328659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f69b91557c8e72d86ca1ff5e328659"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a10f69b91557c8e72d86ca1ff5e328659">SetProxy</a> (const std::string &amp;host, int &amp;port)</td></tr>
<tr class="memdesc:a10f69b91557c8e72d86ca1ff5e328659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the proxy host &amp; port used for http (nhp) communication. <br/></td></tr>
<tr class="separator:a10f69b91557c8e72d86ca1ff5e328659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfafd8f27f3231e21898dd1469b4dd0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#acdfafd8f27f3231e21898dd1469b4dd0">setPushWaitLimit</a> (int p_pushWait)</td></tr>
<tr class="memdesc:acdfafd8f27f3231e21898dd1469b4dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue push wait time.  <a href="#acdfafd8f27f3231e21898dd1469b4dd0">More...</a><br/></td></tr>
<tr class="separator:acdfafd8f27f3231e21898dd1469b4dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472566e14bc1127ed726afeb2614047c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a472566e14bc1127ed726afeb2614047c">setReconnectAfterAccessChange</a> (bool recon)</td></tr>
<tr class="memdesc:a472566e14bc1127ed726afeb2614047c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked.  <a href="#a472566e14bc1127ed726afeb2614047c">More...</a><br/></td></tr>
<tr class="separator:a472566e14bc1127ed726afeb2614047c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db0d48876f6b6bbfbb336324d46a912"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a9db0d48876f6b6bbfbb336324d46a912">setReconnectImmediately</a> (bool recon)</td></tr>
<tr class="memdesc:a9db0d48876f6b6bbfbb336324d46a912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once.  <a href="#a9db0d48876f6b6bbfbb336324d46a912">More...</a><br/></td></tr>
<tr class="separator:a9db0d48876f6b6bbfbb336324d46a912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313d94682ebf9faf3bbf92c54b5efe00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a313d94682ebf9faf3bbf92c54b5efe00">setReconnectInterval</a> (long interval)</td></tr>
<tr class="memdesc:a313d94682ebf9faf3bbf92c54b5efe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately.  <a href="#a313d94682ebf9faf3bbf92c54b5efe00">More...</a><br/></td></tr>
<tr class="separator:a313d94682ebf9faf3bbf92c54b5efe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f423a764c203e0b496ec05ab8b1d64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55f423a764c203e0b496ec05ab8b1d64"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a55f423a764c203e0b496ec05ab8b1d64">SetRelaxedSSLVerification</a> (bool flag)</td></tr>
<tr class="memdesc:a55f423a764c203e0b496ec05ab8b1d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true then there will be no SSL certificate validation, this is not recommended for production and should only be used during debug. <br/></td></tr>
<tr class="separator:a55f423a764c203e0b496ec05ab8b1d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920b4dffbbdb72d908550f27764ad3eb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a920b4dffbbdb72d908550f27764ad3eb">setSocketReceiveBufferSize</a> (int bufSize)</td></tr>
<tr class="memdesc:a920b4dffbbdb72d908550f27764ad3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the inbound socket buffer size.  <a href="#a920b4dffbbdb72d908550f27764ad3eb">More...</a><br/></td></tr>
<tr class="separator:a920b4dffbbdb72d908550f27764ad3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a443204814c0a94b826559ba45b608f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7a443204814c0a94b826559ba45b608f">setSocketSendBufferSize</a> (int bufSize)</td></tr>
<tr class="memdesc:a7a443204814c0a94b826559ba45b608f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the outbound socket buffer size.  <a href="#a7a443204814c0a94b826559ba45b608f">More...</a><br/></td></tr>
<tr class="separator:a7a443204814c0a94b826559ba45b608f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7dca88bd8e0e5bd315d7eb9e82fdb8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aef7dca88bd8e0e5bd315d7eb9e82fdb8">setSubHighWater</a> (int high)</td></tr>
<tr class="memdesc:aef7dca88bd8e0e5bd315d7eb9e82fdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subscriber queue high watermark.  <a href="#aef7dca88bd8e0e5bd315d7eb9e82fdb8">More...</a><br/></td></tr>
<tr class="separator:aef7dca88bd8e0e5bd315d7eb9e82fdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aa58b1c51ec2bf8fd9fa884964633c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af2aa58b1c51ec2bf8fd9fa884964633c">setSubLowWater</a> (int low)</td></tr>
<tr class="memdesc:af2aa58b1c51ec2bf8fd9fa884964633c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subscriber queue low watermark.  <a href="#af2aa58b1c51ec2bf8fd9fa884964633c">More...</a><br/></td></tr>
<tr class="separator:af2aa58b1c51ec2bf8fd9fa884964633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26b55f49918a5040ce79678f601b687"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ad26b55f49918a5040ce79678f601b687">setWriteHandlerType</a> (int type)</td></tr>
<tr class="memdesc:ad26b55f49918a5040ce79678f601b687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to specify the type of write handling that the client code will employ.  <a href="#ad26b55f49918a5040ce79678f601b687">More...</a><br/></td></tr>
<tr class="separator:ad26b55f49918a5040ce79678f601b687"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a83bf11e0779a7f5676097ffb4c5b37c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83bf11e0779a7f5676097ffb4c5b37c2"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a83bf11e0779a7f5676097ffb4c5b37c2">CHAN_DELETED_EVENT_ID</a> = -2</td></tr>
<tr class="memdesc:a83bf11e0779a7f5676097ffb4c5b37c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the CHANNEL DELETED event ID received as result of channel deletion This event is send only when async subscriber is used. <br/></td></tr>
<tr class="separator:a83bf11e0779a7f5676097ffb4c5b37c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9030192a4111c653a4ae6967706bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b9030192a4111c653a4ae6967706bc3"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a1b9030192a4111c653a4ae6967706bc3">m_sDirectWriteHandler</a> = fConnectionSettings::sDirectWriteHandler</td></tr>
<tr class="memdesc:a1b9030192a4111c653a4ae6967706bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This write handler only uses a direct write method to the network layer, this reduces latencies but may increase the cpu used. <br/></td></tr>
<tr class="separator:a1b9030192a4111c653a4ae6967706bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa18fc26c2c381b3def89ffd66733db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaa18fc26c2c381b3def89ffd66733db"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#adaa18fc26c2c381b3def89ffd66733db">m_sStandardWriteHandler</a> = fConnectionSettings::sPeakWriteHandler</td></tr>
<tr class="memdesc:adaa18fc26c2c381b3def89ffd66733db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This write handler uses a combination of direct writing and buffered writing to the network depending on client event load. <br/></td></tr>
<tr class="separator:adaa18fc26c2c381b3def89ffd66733db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a container for the various constants that affect the behaviour of various Nirvana Client API calls. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a99b2ae226067dfdb8e0e563208c433fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool com::pcbsys::nirvana::client::nConstants::attemptReconnectAfterAccessChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked. </p>
<p>By default, the <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will not reconnect after one of these incidents, and a manual restart would need to be initiated</p>
<dl class="section return"><dt>Returns</dt><dd>true if reconnect is enabled after realm ACL subject revocation </dd></dl>

</div>
</div>
<a class="anchor" id="a7dfb6f7527cc8170d1b36c4ceda4cf6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool com::pcbsys::nirvana::client::nConstants::attemptReconnectImmediately </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once. </p>
<dl class="section return"><dt>Returns</dt><dd>true if reconnect immediately is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="a0331ab895cc6486ce6aa0f841796c0f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::compareNoCase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare 2 strings for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>the 1st string in comparison </td></tr>
    <tr><td class="paramname">string2</td><td>the 2nd string in comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of string1.compare(string2) </dd></dl>

</div>
</div>
<a class="anchor" id="ade1546ebb17aee7adfc5e7dc5c74b62b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static longlong com::pcbsys::nirvana::client::nConstants::currentTimeMillis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an Epoch Date in milliseconds representing the current system date / time. </p>
<dl class="section return"><dt>Returns</dt><dd>Epoch time as a long </dd></dl>

</div>
</div>
<a class="anchor" id="a7c2e48da8d3a7c575b12730da76c98c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::decode </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the array into a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>the array to decode </td></tr>
    <tr><td class="paramname">size</td><td>the size of the array </td></tr>
    <tr><td class="paramname">str</td><td>the string to decode into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45250e13e795a190a5105011200017f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char* com::pcbsys::nirvana::client::nConstants::encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode the string into an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to encode </td></tr>
    <tr><td class="paramname">size</td><td>the size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded array </dd></dl>

</div>
</div>
<a class="anchor" id="a28dab593aae84c210a173725590c0c01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getAccessWaitLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue access wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that the queue cannot be accessed. This period is called the block access time</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue access wait </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aacb4377a8f2bb820a66a87aa72ca62ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getBlockLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue block wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. This period is called the block wait time</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue block wait </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5042646be0acabbcfe64a646c65b3251"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; com::pcbsys::nirvana::client::nConstants::getClientBuildNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the client build number information. </p>
<dl class="section return"><dt>Returns</dt><dd>the client build number information as a string </dd></dl>

</div>
</div>
<a class="anchor" id="a2d1852cbe18b2edc85ddfbc8af741762"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getConnectionBlockWeighting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue block weighting. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. The connection block weighting is a value that is applied to the block wait value in order to control the frequency of these notifications.</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue block weighting </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a45f0f9ae3e06892c4a624624228c34ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getConnectionQueueHighWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue high watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>the outbound connection queue high water mark </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66cb8a1ae7ae7f6d8fb563393589044c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getConnectionQueueLowWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue low watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>the outbound connection queue low water mark </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aafb9c528c2ea3f56d743a0e134f38aca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getDataGroupQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current data group event queue size </dd></dl>

</div>
</div>
<a class="anchor" id="a06cd58665a3b55dd732579beb060713b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool com::pcbsys::nirvana::client::nConstants::getEnabledPriorityQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether priority queueing is enabled for this client. </p>
<dl class="section return"><dt>Returns</dt><dd>true if priority queueing is enabled for this client, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a531a2e5500397ab21de5850800081b45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long com::pcbsys::nirvana::client::nConstants::getEVENTWAIT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm. </p>
<p>The default value is 60 secs and typically if you get a <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a> the cause would be:</p>
<ol type="1">
<li>There is a protocol mismatch between the client library in use and server you are connected to. </li>
</ol>
<ol type="1">
<li>The realm is really so busy that it has not managed to respond to your request within the specified maximum interval. </li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>a long specifying the maximum wait time for a protocol request (in ms) </dd></dl>

</div>
</div>
<a class="anchor" id="a445da42709df623a1b1d35f8c9322e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getInitialConnectionTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the current value for the Initial socket connect timeout. </p>
<p>This timeout is specified in the actual underlying Socket connect, and enables connections made to non existent or unreachable hosts to be returned within a configurable time frame</p>
<dl class="section return"><dt>Returns</dt><dd>the socket connect timeout value, default is 30000ms </dd></dl>

</div>
</div>
<a class="anchor" id="a034e4af93a6a0498d9ecc60e2abee1ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long com::pcbsys::nirvana::client::nConstants::getKeepAliveInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value in ms to wait before sending a Keep Alive. </p>
<p>This is relevant to the local client only. </p>

</div>
</div>
<a class="anchor" id="a286e853c869b2ce8ba1e73f906092351"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getPushWaitLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue push wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that events cannot be pushed to the queue. This period is called the push wait time</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue push wait </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c06e7460aa52650b05d37f86d1913e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long com::pcbsys::nirvana::client::nConstants::getReconnectInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>true if reconnect immediately is enabled </dd></dl>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a72928faee5407879deefa7a59b9aa43d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getSocketReceiveBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inbound socket buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes for the inbound buffer size </dd></dl>

</div>
</div>
<a class="anchor" id="a7180f93c14a4f848dbde045db5934c4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getSocketSendBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the outbound socket buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes for the outbound buffer size </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc6b11b5bafeedb81fc6781481455c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getSubHighWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the subscriber queue high watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>an int specifying the number of events to be used as a queue high watermark </dd></dl>

</div>
</div>
<a class="anchor" id="a872764b648ddb53011a3cf6fb9441182"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getSubLowWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the subscriber queue low watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>an int specifying the number of events to be used as a queue low watermark </dd></dl>

</div>
</div>
<a class="anchor" id="adcff84b9328d9afaed169c5f894a48ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com::pcbsys::nirvana::client::nConstants::getWriteHandlerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current write handling mode that the client is using. </p>
<dl class="section return"><dt>Returns</dt><dd>an int of either sStandardWriteHandler or sDirectWriteHandler </dd></dl>

</div>
</div>
<a class="anchor" id="ac53702525d32692da7115863bb08e005"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static time_t com::pcbsys::nirvana::client::nConstants::milliToDateTime </td>
          <td>(</td>
          <td class="paramtype">longlong&#160;</td>
          <td class="paramname"><em>millis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts milliseconds (time since EPOCH) into a time object;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millis</td><td>time since EPOCH </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time_t representation of millis </dd></dl>

</div>
</div>
<a class="anchor" id="a1d011f1e4b86ffcc2d52326f4531cbd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static longlong com::pcbsys::nirvana::client::nConstants::nanoTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return current time in nanoseconds. </p>
<dl class="section return"><dt>Returns</dt><dd>current time in nanoseconds </dd></dl>

</div>
</div>
<a class="anchor" id="a4e3a1cdaa7d15b16daf6aab453bfc636"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setAccessWaitLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_accessWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue access wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that the queue cannot be accessed. This period is called the block access time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_accessWait</td><td>the connection queue access wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acf19bac701097975b3ec25e6a7e92f3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setBlockLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_blockWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue block wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. This period is called the block wait time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_blockWait</td><td>the connection queue block wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8310654ed7fb01288e2737d9374e5206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setClientLogFile </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify a file for the client log messages. </p>
<p>Defaults to stdout. </p>

</div>
</div>
<a class="anchor" id="a38e2741a3eca6e7fb5749f1b8e875e10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setClientLogLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the log level for the client. </p>
<p>All Nirvana client api code contains useful logging messages. The messages are set at specific levels from 0-7. This method allows you to choose what log level you wish to see. Setting to log level 0 will provide verbose output, whereas level 7 will be fairly quiet.</p>
<p>By default, these messages will be sent to the console output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the log level you wish to set the client application to for nirvana messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af99939c84155c8b02b7705c79dbf132a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setConnectionBlockWeighting </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockWeighting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue block weighting. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. The connection block weighting is a value that is applied to the block wait value in order to control the frequency of these notifications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockWeighting</td><td>the connection queue block weighting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42820332c03ae1b8ca8401f8bcc91da8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setConnectionQueueHighWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue high watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>the outbound connection queue high water mark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae594c828c3d3b11887de2a5b861e02ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setConnectionQueueLowWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue low watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>the outbound connection queue low water mark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af01777835e33a2e7f5ebb105febefa3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setDataGroupQueueSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of events that are still to ve delivered to the client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueSize</td><td>number of events that the queue will hold before blocking </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fe0c04afe85c345113672aa95e4ee22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setEnabledPriorityQueues </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the usage of priority queues for this client. </p>
<p>This will give delivery preference to messages marked high priority for this client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>boolean true will enable priority queueing for this client, false will disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a074b7fc024537b046456928271708ff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setEVENTWAIT </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm. </p>
<p>The default value is 60 secs and typically if you get a <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a> the cause would be:</p>
<ol type="1">
<li>There is a protocol mismatch between the client library in use and server you are connected to. </li>
</ol>
<ol type="1">
<li>The realm is really so busy that it has not managed to respond to your request within the specified maximum interval. </li>
</ol>
<p>Calling this method will only have effect on the local client. Alternatively if you change this value through on the realm configuration using the Admin API, all subsequent Nirvana clients that connect will be affected. </p>

</div>
</div>
<a class="anchor" id="a68c4b27ca98ab24c4a1ce0107019d056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setHonourThirdPartyCookies </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doHonour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If honourThirdPartyCookies is set to true then the client will maintain any third party cookies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doHonour</td><td>if true the client will maintain third party cookies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>6.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a6f3896983fa76017d6982f34458c9a4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setInitialConnectionTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets the current value for the Initial socket connect timeout. </p>
<p>This timeout is specified in the actual underlying Socket connect, and enables connections made to non existent or unreachable hosts to be returned within a configurable time frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the socket connect timeout value to be set, default is 30000ms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac14235115402b660a556f3c3126d72d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setKeepAliveInterval </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value in ms to wait before sending a Keep Alive. </p>
<p>This is applied to the local client only and is NOT sent to the realm. </p>

</div>
</div>
<a class="anchor" id="a8bb7701d25c1a77d8898c7e3e580aab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setPermittedKeepAlivesMissed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of keep alives that the client can miss before closing the connection. </p>
<p>If 0, the client does not check for any missed keep alives from the server and will continue sending its own keep alive events, until the connection is detected as lost. If &gt; 0, say 1, when the client has not received a message for 1 X the KeepAlive time + 20000ms, the underlying connection will be closed by the client and reconnection will be attempted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kas</td><td>Number of keep alive messages the client will miss before determining the connection as broken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdfafd8f27f3231e21898dd1469b4dd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setPushWaitLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_pushWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue push wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that events cannot be pushed to the queue. This period is called the push wait time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_pushWait</td><td>the connection queue push wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a472566e14bc1127ed726afeb2614047c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setReconnectAfterAccessChange </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked. </p>
<p>By default, the <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will not reconnect after one of these incidents, and a manual restart would need to be initiated</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recon</td><td>true - will reconnect continually until successful, false, will disabled reconnect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9db0d48876f6b6bbfbb336324d46a912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setReconnectImmediately </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recon</td><td>true - will reconnect immediately, and use the value set in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a313d94682ebf9faf3bbf92c54b5efe00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setReconnectInterval </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>value in milliseconds specifying the interval between reconnect attempts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a920b4dffbbdb72d908550f27764ad3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setSocketReceiveBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the inbound socket buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufSize</td><td>the size in bytes for the inbound buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a443204814c0a94b826559ba45b608f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setSocketSendBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the outbound socket buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufSize</td><td>the size in bytes for the outbound buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef7dca88bd8e0e5bd315d7eb9e82fdb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setSubHighWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the subscriber queue high watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>sets the subscriber high water mark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2aa58b1c51ec2bf8fd9fa884964633c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setSubLowWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the subscriber queue low watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>the low water ,ark for the subscriber </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad26b55f49918a5040ce79678f601b687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com::pcbsys::nirvana::client::nConstants::setWriteHandlerType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the client to specify the type of write handling that the client code will employ. </p>
<p>Please note this needs to be set prior to any <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Either sStandardWriteHandler or sDirectWriteHandler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div> <!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  --> <!-- end main -->
</div> <!-- end wrapper -->
<div id="footer">
<div>
Copyright &copy; 2020 Software AG, Darmstadt Germany
and/or Software AG USA, Inc., Reston, VA, United States of America,
and/or their licensors.
<br/>
</div>
</div> <!-- end footer -->
</body>
</html>
