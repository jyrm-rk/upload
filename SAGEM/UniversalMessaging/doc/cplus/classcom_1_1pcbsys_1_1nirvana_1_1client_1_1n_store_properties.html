<!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>com::pcbsys::nirvana::client::nStoreProperties Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="nirvana.css" />
</head>
<body>
<div id="topbar">
<a href="http://www.universalmessaging.org/"><img id="logo" border="0" src="logo.png"/></a>
</div>
<div class="wrapper">
<div id="main">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecom.html">com</a></li><li class="navelem"><b>pcbsys</b></li><li class="navelem"><b>nirvana</b></li><li class="navelem"><a class="el" href="namespacecom_1_1pcbsys_1_1nirvana_1_1client.html">client</a></li><li class="navelem"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html">nStoreProperties</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">com::pcbsys::nirvana::client::nStoreProperties Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that contains additional properties that can be set on the channel or queue.  
 <a href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#details">More...</a></p>

<p><code>#include &lt;nStoreProperties.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a87a43d71d4f30bd97012d19247b3ddc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a87a43d71d4f30bd97012d19247b3ddc1">canSyncOnEachWrite</a> ()</td></tr>
<tr class="memdesc:a87a43d71d4f30bd97012d19247b3ddc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether each write to the store will also call sync on the file system to ensure all data is written to the Disk.  <a href="#a87a43d71d4f30bd97012d19247b3ddc1">More...</a><br/></td></tr>
<tr class="separator:a87a43d71d4f30bd97012d19247b3ddc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7ea338a8b6a613530d6a3484484086"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a6b7ea338a8b6a613530d6a3484484086">getCacheOnReload</a> ()</td></tr>
<tr class="memdesc:a6b7ea338a8b6a613530d6a3484484086"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a server restarts it will scan all file based stores and check for corruption.  <a href="#a6b7ea338a8b6a613530d6a3484484086">More...</a><br/></td></tr>
<tr class="separator:a6b7ea338a8b6a613530d6a3484484086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddfb0e0c9c88a98213d9a55bb86d587"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a6ddfb0e0c9c88a98213d9a55bb86d587">getClientMergeEngineClassname</a> ()</td></tr>
<tr class="memdesc:a6ddfb0e0c9c88a98213d9a55bb86d587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured merge class name, if supplied else null.  <a href="#a6ddfb0e0c9c88a98213d9a55bb86d587">More...</a><br/></td></tr>
<tr class="separator:a6ddfb0e0c9c88a98213d9a55bb86d587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87e1b3ee9b93715994c1ca566453f04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#ad87e1b3ee9b93715994c1ca566453f04">getEnableCaching</a> ()</td></tr>
<tr class="memdesc:ad87e1b3ee9b93715994c1ca566453f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the server will cache events in memory or will always refer back to the file backed store.  <a href="#ad87e1b3ee9b93715994c1ca566453f04">More...</a><br/></td></tr>
<tr class="separator:ad87e1b3ee9b93715994c1ca566453f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f27de12f54c6a1acbbb97c1a504d9f9"><td class="memItemLeft" align="right" valign="top">UM_DEPRECATED bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a8f27de12f54c6a1acbbb97c1a504d9f9">getEnableReadBuffering</a> ()</td></tr>
<tr class="memdesc:a8f27de12f54c6a1acbbb97c1a504d9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of read buffering for the store, if true, then reads will be buffered to optimize the I/O access to the file based store.  <a href="#a8f27de12f54c6a1acbbb97c1a504d9f9">More...</a><br/></td></tr>
<tr class="separator:a8f27de12f54c6a1acbbb97c1a504d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72724cf5ca5ef530397ebb9c97c09fd2"><td class="memItemLeft" align="right" valign="top">UM_DEPRECATED std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a72724cf5ca5ef530397ebb9c97c09fd2">getFanoutArchiveTarget</a> ()</td></tr>
<tr class="memdesc:a72724cf5ca5ef530397ebb9c97c09fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured fanout archive target name, if supplied else null.  <a href="#a72724cf5ca5ef530397ebb9c97c09fd2">More...</a><br/></td></tr>
<tr class="separator:a72724cf5ca5ef530397ebb9c97c09fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfc2f3529132fca7b0f42698fb406c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#adbfc2f3529132fca7b0f42698fb406c9">getHonorCapacityWhenFull</a> ()</td></tr>
<tr class="memdesc:adbfc2f3529132fca7b0f42698fb406c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the channel / queue capacity setting will prevent publishing of any more data once full.  <a href="#adbfc2f3529132fca7b0f42698fb406c9">More...</a><br/></td></tr>
<tr class="separator:adbfc2f3529132fca7b0f42698fb406c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac677fa6c5783179e1f98e45aa2328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a33ac677fa6c5783179e1f98e45aa2328">getMultiFileEventsPerSpindle</a> ()</td></tr>
<tr class="memdesc:a33ac677fa6c5783179e1f98e45aa2328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of events that are stored per individual files for a single store.  <a href="#a33ac677fa6c5783179e1f98e45aa2328">More...</a><br/></td></tr>
<tr class="separator:a33ac677fa6c5783179e1f98e45aa2328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8a119a5c248d11c753c7a0d1eebd90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a3e8a119a5c248d11c753c7a0d1eebd90">getPerformAutomaticMaintenance</a> ()</td></tr>
<tr class="memdesc:a3e8a119a5c248d11c753c7a0d1eebd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the store will be have automatic maintenance as events are being removed.  <a href="#a3e8a119a5c248d11c753c7a0d1eebd90">More...</a><br/></td></tr>
<tr class="separator:a3e8a119a5c248d11c753c7a0d1eebd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb49b0f1924ea40e076b61ebc44cc0ae"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#afb49b0f1924ea40e076b61ebc44cc0ae">getPriority</a> ()</td></tr>
<tr class="memdesc:afb49b0f1924ea40e076b61ebc44cc0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the priority for the associated resource.  <a href="#afb49b0f1924ea40e076b61ebc44cc0ae">More...</a><br/></td></tr>
<tr class="separator:afb49b0f1924ea40e076b61ebc44cc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4561faeff462e3fc4869d74e02ee65"><td class="memItemLeft" align="right" valign="top">UM_DEPRECATED ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#acb4561faeff462e3fc4869d74e02ee65">getReadBufferSize</a> ()</td></tr>
<tr class="memdesc:acb4561faeff462e3fc4869d74e02ee65"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ReadBuffering is enabled then this function returns the size in bytes of the buffer to use.  <a href="#acb4561faeff462e3fc4869d74e02ee65">More...</a><br/></td></tr>
<tr class="separator:acb4561faeff462e3fc4869d74e02ee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1304dd467575e149a03ad7e4a137f78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#ae1304dd467575e149a03ad7e4a137f78">getStampDictionary</a> ()</td></tr>
<tr class="memdesc:ae1304dd467575e149a03ad7e4a137f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the StampDictionary setting value of this store.  <a href="#ae1304dd467575e149a03ad7e4a137f78">More...</a><br/></td></tr>
<tr class="separator:ae1304dd467575e149a03ad7e4a137f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ba91ba30d197df2581c03c5c82fc74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#ac9ba91ba30d197df2581c03c5c82fc74">getSyncBatchTime</a> ()</td></tr>
<tr class="memdesc:ac9ba91ba30d197df2581c03c5c82fc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether each write to the store will also call sync on the file system to ensure all data is written to the Disk.  <a href="#ac9ba91ba30d197df2581c03c5c82fc74">More...</a><br/></td></tr>
<tr class="separator:ac9ba91ba30d197df2581c03c5c82fc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080921d8a99f7b3237dd701bbf1e9c62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a080921d8a99f7b3237dd701bbf1e9c62">getSyncMaxBatchSize</a> ()</td></tr>
<tr class="memdesc:a080921d8a99f7b3237dd701bbf1e9c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether each write to the store will also call sync on the file system to ensure all data is written to the Disk.  <a href="#a080921d8a99f7b3237dd701bbf1e9c62">More...</a><br/></td></tr>
<tr class="separator:a080921d8a99f7b3237dd701bbf1e9c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851ee7bc4e518cce56abb4babce44032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a851ee7bc4e518cce56abb4babce44032">setCacheOnReload</a> (bool flag)</td></tr>
<tr class="memdesc:a851ee7bc4e518cce56abb4babce44032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to control the caching algorithm within the server, if you set caching to false, all events will be read from the file store else if ther server has room in memory, they will be stored in memory and reused.  <a href="#a851ee7bc4e518cce56abb4babce44032">More...</a><br/></td></tr>
<tr class="separator:a851ee7bc4e518cce56abb4babce44032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79a49d1f40c4fa5df2a0b06c646c5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#ad79a49d1f40c4fa5df2a0b06c646c5c6">setClientMergeEngineClassname</a> (const std::string &amp;mergeEngineClass)</td></tr>
<tr class="memdesc:ad79a49d1f40c4fa5df2a0b06c646c5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows the client to specify the class used to merge events to form one event within the server.  <a href="#ad79a49d1f40c4fa5df2a0b06c646c5c6">More...</a><br/></td></tr>
<tr class="separator:ad79a49d1f40c4fa5df2a0b06c646c5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99738b9e3559bbc1ed62d17d775b163b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a99738b9e3559bbc1ed62d17d775b163b">setEnableCaching</a> (bool flag)</td></tr>
<tr class="memdesc:a99738b9e3559bbc1ed62d17d775b163b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to control the caching algorithm within the server, if you set caching to false, all events will be read from the file store else if ther server has room in memory, they will be stored in memory and reused.  <a href="#a99738b9e3559bbc1ed62d17d775b163b">More...</a><br/></td></tr>
<tr class="separator:a99738b9e3559bbc1ed62d17d775b163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbec40cec2bd7ad703682c7bca6f449"><td class="memItemLeft" align="right" valign="top">UM_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#adbbec40cec2bd7ad703682c7bca6f449">setEnableReadBuffering</a> (bool flag)</td></tr>
<tr class="memdesc:adbbec40cec2bd7ad703682c7bca6f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to control the read buffering logic for the store on the server.  <a href="#adbbec40cec2bd7ad703682c7bca6f449">More...</a><br/></td></tr>
<tr class="separator:adbbec40cec2bd7ad703682c7bca6f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c56f73d670adf21623854a029f6b0"><td class="memItemLeft" align="right" valign="top">UM_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a577c56f73d670adf21623854a029f6b0">setFanoutArchiveTarget</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a577c56f73d670adf21623854a029f6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows the client to specify the name of an existing channel or queue which will be used to archive every single event that the server fans out to this channel's subscribers, stamped with fanout information.  <a href="#a577c56f73d670adf21623854a029f6b0">More...</a><br/></td></tr>
<tr class="separator:a577c56f73d670adf21623854a029f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e46581cef14fbcfa58afdff216e416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a61e46581cef14fbcfa58afdff216e416">setHonorCapacityWhenFull</a> (bool flag)</td></tr>
<tr class="memdesc:a61e46581cef14fbcfa58afdff216e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the channel / queue capacity setting will prevent publishing of events once full.  <a href="#a61e46581cef14fbcfa58afdff216e416">More...</a><br/></td></tr>
<tr class="separator:a61e46581cef14fbcfa58afdff216e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7735b9a466c52d8decea7e2ea9ec64f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#af7735b9a466c52d8decea7e2ea9ec64f">setMultiFileEventsPerSpindle</a> (unsigned int count)</td></tr>
<tr class="memdesc:af7735b9a466c52d8decea7e2ea9ec64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of events that will be stored per individual file for a store.  <a href="#af7735b9a466c52d8decea7e2ea9ec64f">More...</a><br/></td></tr>
<tr class="separator:af7735b9a466c52d8decea7e2ea9ec64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5711266df7f1bc3a190973d6419ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#aa3f5711266df7f1bc3a190973d6419ad">setPerformAutomaticMaintenance</a> (bool flag)</td></tr>
<tr class="memdesc:aa3f5711266df7f1bc3a190973d6419ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the store will be have automatic maintenance as events are being removed.  <a href="#aa3f5711266df7f1bc3a190973d6419ad">More...</a><br/></td></tr>
<tr class="separator:aa3f5711266df7f1bc3a190973d6419ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0323ca04aad5e80d31e3567142c5b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#aff0323ca04aad5e80d31e3567142c5b6">setPriority</a> (unsigned int newPriority)</td></tr>
<tr class="memdesc:aff0323ca04aad5e80d31e3567142c5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default message priority for events on this channel.  <a href="#aff0323ca04aad5e80d31e3567142c5b6">More...</a><br/></td></tr>
<tr class="separator:aff0323ca04aad5e80d31e3567142c5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e049dd1cd1dcda47676fe2200cff8"><td class="memItemLeft" align="right" valign="top">UM_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a6d2e049dd1cd1dcda47676fe2200cff8">setReadBufferSize</a> (ulonglong size)</td></tr>
<tr class="memdesc:a6d2e049dd1cd1dcda47676fe2200cff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If read buffering is enabled then this allows the client set the number of bytes used for buffering.  <a href="#a6d2e049dd1cd1dcda47676fe2200cff8">More...</a><br/></td></tr>
<tr class="separator:a6d2e049dd1cd1dcda47676fe2200cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881ac80405d4727e6455a5a54d936825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a881ac80405d4727e6455a5a54d936825">setStampDictionary</a> (int stampDictionary)</td></tr>
<tr class="memdesc:a881ac80405d4727e6455a5a54d936825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure explicitly the value of the StampDictionary setting of this store.  <a href="#a881ac80405d4727e6455a5a54d936825">More...</a><br/></td></tr>
<tr class="separator:a881ac80405d4727e6455a5a54d936825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c62320a395c14e8683eae8a6d3204b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a6c62320a395c14e8683eae8a6d3204b0">setSyncBatchTime</a> (int size)</td></tr>
<tr class="memdesc:a6c62320a395c14e8683eae8a6d3204b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether each write to the store will also call sync on the file system to ensure all data is written to the Disk.  <a href="#a6c62320a395c14e8683eae8a6d3204b0">More...</a><br/></td></tr>
<tr class="separator:a6c62320a395c14e8683eae8a6d3204b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f15023ed90a0a15aa3af93b700ffcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#ae8f15023ed90a0a15aa3af93b700ffcf">setSyncMaxBatchSize</a> (int size)</td></tr>
<tr class="memdesc:ae8f15023ed90a0a15aa3af93b700ffcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether each write to the store will also call sync on the file system to ensure all data is written to the Disk.  <a href="#ae8f15023ed90a0a15aa3af93b700ffcf">More...</a><br/></td></tr>
<tr class="separator:ae8f15023ed90a0a15aa3af93b700ffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eacf87cdc3566560e43ad9cd338b69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_store_properties.html#a47eacf87cdc3566560e43ad9cd338b69">setSyncOnEachWrite</a> (bool flag)</td></tr>
<tr class="memdesc:a47eacf87cdc3566560e43ad9cd338b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether each write to the store will also call sync on the file system to ensure all data is written to the Disk.  <a href="#a47eacf87cdc3566560e43ad9cd338b69">More...</a><br/></td></tr>
<tr class="separator:a47eacf87cdc3566560e43ad9cd338b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that contains additional properties that can be set on the channel or queue. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a87a43d71d4f30bd97012d19247b3ddc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nStoreProperties::canSyncOnEachWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether each write to the store will also call sync on the file system to ensure all data is written to the Disk. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7ea338a8b6a613530d6a3484484086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nStoreProperties::getCacheOnReload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a server restarts it will scan all file based stores and check for corruption. </p>
<p>During this test the default behaviour is to disable caching to conserve memory, however, in some instances it would be better if the server had actually cached the events in memory for fast replay.</p>
<dl class="section return"><dt>Returns</dt><dd>The current state, if false (default behaviour) no events are kept in memory during reload </dd></dl>

</div>
</div>
<a class="anchor" id="a6ddfb0e0c9c88a98213d9a55bb86d587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string com::pcbsys::nirvana::client::nStoreProperties::getClientMergeEngineClassname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently configured merge class name, if supplied else null. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of class which implements interface nMergeEngineExtension.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>com.pcbsys.nirvana.server.plugins.extensions.mergeEngine.nMergeEngineExtension </dd></dl>

</div>
</div>
<a class="anchor" id="ad87e1b3ee9b93715994c1ca566453f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nStoreProperties::getEnableCaching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the server will cache events in memory or will always refer back to the file backed store. </p>
<p>Used by mixed and persistent store types to improve performance by caching the event in memory. In certain instances this is not desirable and the events should not be cached, some examples would be very large stores where the application will periodically scan from the start to the finish.</p>
<dl class="section return"><dt>Returns</dt><dd>true if enabled, this is the default behaviour </dd></dl>

</div>
</div>
<a class="anchor" id="a8f27de12f54c6a1acbbb97c1a504d9f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UM_DEPRECATED bool com::pcbsys::nirvana::client::nStoreProperties::getEnableReadBuffering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state of read buffering for the store, if true, then reads will be buffered to optimize the I/O access to the file based store. </p>
<p>If false then no buffering will be done and each read will result in a disk I/O, reducing overall performance of the server.</p>
<dl class="section return"><dt>Returns</dt><dd>boolean indicating if read buffering is enabled or not. By default it is enabled </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>This function is deprecated since 10.3. Read buffering is always enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a72724cf5ca5ef530397ebb9c97c09fd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UM_DEPRECATED std::string com::pcbsys::nirvana::client::nStoreProperties::getFanoutArchiveTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently configured fanout archive target name, if supplied else null. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of class which implements interface nMergeEngineExtension. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>This method is deprecated since 10.5. The Archive functionality is not complete and has various limitations. It will be removed from the product in the next releases </dd></dl>

</div>
</div>
<a class="anchor" id="adbfc2f3529132fca7b0f42698fb406c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nStoreProperties::getHonorCapacityWhenFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the channel / queue capacity setting will prevent publishing of any more data once full. </p>
<p>If true, the client will get an exception on further publishes </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a33ac677fa6c5783179e1f98e45aa2328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com::pcbsys::nirvana::client::nStoreProperties::getMultiFileEventsPerSpindle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of events that are stored per individual files for a single store. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of events per file spindle </dd></dl>

</div>
</div>
<a class="anchor" id="a3e8a119a5c248d11c753c7a0d1eebd90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::pcbsys::nirvana::client::nStoreProperties::getPerformAutomaticMaintenance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the store will be have automatic maintenance as events are being removed. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="afb49b0f1924ea40e076b61ebc44cc0ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int com::pcbsys::nirvana::client::nStoreProperties::getPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the priority for the associated resource. </p>
<dl class="section return"><dt>Returns</dt><dd>an integer between 0 and 9, representing the inherited priority for events on this channel </dd></dl>

</div>
</div>
<a class="anchor" id="acb4561faeff462e3fc4869d74e02ee65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UM_DEPRECATED ulonglong com::pcbsys::nirvana::client::nStoreProperties::getReadBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If ReadBuffering is enabled then this function returns the size in bytes of the buffer to use. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes to use for buffering reads for the store </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>This function is deprecated since 10.3. Stores will always use the global 'StoreReadBufferSize' realm configuration. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1304dd467575e149a03ad7e4a137f78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com::pcbsys::nirvana::client::nStoreProperties::getStampDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the StampDictionary setting value of this store. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_attributes.html#a26ed8c8226d798ac6cbaea300414286f" title="Dictionary stamping state - ENABLED. ">com.pcbsys.nirvana.client.nChannelAttributes::DICTIONARY_STAMPING_ENABLED</a></code> if dictionary stamping is explicitly enabled for this channel </li>
<li>
<code><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_attributes.html#a403a1a58d523dabfa3f96005e2ecbef8" title="Dictionary stamping state - DISABLED. ">com.pcbsys.nirvana.client.nChannelAttributes::DICTIONARY_STAMPING_DISABLED</a></code> if dictionary stamping is explicitly disabled for this channel </li>
<li>
<code><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_attributes.html#ac5d302bee720c34f8a250e70c49c1018" title="Dictionary stamping state - DEFAULT By default the engine will fall back to the server-wide configura...">com.pcbsys.nirvana.client.nChannelAttributes::DICTIONARY_STAMPING_DEFAULT</a></code> if dictionary stamping is not explicitly configured for this channel (the server will behave according to the default (server-wide) configuration setting) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac9ba91ba30d197df2581c03c5c82fc74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com::pcbsys::nirvana::client::nStoreProperties::getSyncBatchTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether each write to the store will also call sync on the file system to ensure all data is written to the Disk. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a080921d8a99f7b3237dd701bbf1e9c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com::pcbsys::nirvana::client::nStoreProperties::getSyncMaxBatchSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether each write to the store will also call sync on the file system to ensure all data is written to the Disk. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a851ee7bc4e518cce56abb4babce44032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setCacheOnReload </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to control the caching algorithm within the server, if you set caching to false, all events will be read from the file store else if ther server has room in memory, they will be stored in memory and reused. </p>
<p>Only applicable for mixed and persistent stores</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>true to enable caching (default behaviour) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad79a49d1f40c4fa5df2a0b06c646c5c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setClientMergeEngineClassname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mergeEngineClass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This allows the client to specify the class used to merge events to form one event within the server. </p>
<p>The class must implement the interface nMergeEngineExtension and the channel must have the merge engine active else this will not be used by the server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of the class to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99738b9e3559bbc1ed62d17d775b163b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setEnableCaching </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to control the caching algorithm within the server, if you set caching to false, all events will be read from the file store else if ther server has room in memory, they will be stored in memory and reused. </p>
<p>Only applicable for mixed and persistent stores</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>true to enable caching (default behaviour) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbbec40cec2bd7ad703682c7bca6f449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UM_DEPRECATED void com::pcbsys::nirvana::client::nStoreProperties::setEnableReadBuffering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to control the read buffering logic for the store on the server. </p>
<p>If true then the server will optimize its reading of the file based store and reduce the number of disk I/O's performed. Only works on file backed stores like mixed and persistent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>to enable/disable the read buffering </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>This function is deprecated since 10.3. Read buffering is always enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a577c56f73d670adf21623854a029f6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UM_DEPRECATED void com::pcbsys::nirvana::client::nStoreProperties::setFanoutArchiveTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This allows the client to specify the name of an existing channel or queue which will be used to archive every single event that the server fans out to this channel's subscribers, stamped with fanout information. </p>
<p>The functionality only applies to channels, will have no effect if used on a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of the existing channel or queue to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>This method is deprecated since 10.5. The Archive functionality is not complete and has various limitations. It will be removed from the product in the next releases </dd></dl>

</div>
</div>
<a class="anchor" id="a61e46581cef14fbcfa58afdff216e416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setHonorCapacityWhenFull </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the channel / queue capacity setting will prevent publishing of events once full. </p>
<p>If true, the client will get an exception on further publishes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>true and no more events after max events will be published </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7735b9a466c52d8decea7e2ea9ec64f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setMultiFileEventsPerSpindle </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of events that will be stored per individual file for a store. </p>
<p>Setting this number too low will create to many files and utilise a large number of file descriptors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of events per individual file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3f5711266df7f1bc3a190973d6419ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setPerformAutomaticMaintenance </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the store will be have automatic maintenance as events are being removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>true or false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff0323ca04aad5e80d31e3567142c5b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setPriority </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>newPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default message priority for events on this channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPriority</td><td>an integer priority between 1 and 10, where 10 is the highest priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the value of newPriority is not between 1 and 10, this exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d2e049dd1cd1dcda47676fe2200cff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UM_DEPRECATED void com::pcbsys::nirvana::client::nStoreProperties::setReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If read buffering is enabled then this allows the client set the number of bytes used for buffering. </p>
<p>By default the server uses 10K</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferSize</td><td>number of bytes to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>This function is deprecated since 10.3. Stores will always use the global 'StoreReadBufferSize' realm configuration. </dd></dl>

</div>
</div>
<a class="anchor" id="a881ac80405d4727e6455a5a54d936825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setStampDictionary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stampDictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure explicitly the value of the StampDictionary setting of this store. </p>
<p>This configuration setting will override the default server behavior when processing events on this channel. <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stampDictionary</td><td>the new value of the configuration setting. Valid values are: <br/>
 <ul>
<li>
<code><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_attributes.html#a26ed8c8226d798ac6cbaea300414286f" title="Dictionary stamping state - ENABLED. ">com.pcbsys.nirvana.client.nChannelAttributes::DICTIONARY_STAMPING_ENABLED</a></code> to explicitly enable dictionary stamping for this channel </li>
<li>
<code><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_attributes.html#a403a1a58d523dabfa3f96005e2ecbef8" title="Dictionary stamping state - DISABLED. ">com.pcbsys.nirvana.client.nChannelAttributes::DICTIONARY_STAMPING_DISABLED</a></code> to explicitly disable dictionary stamping for this channel </li>
<li>
<code><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_channel_attributes.html#ac5d302bee720c34f8a250e70c49c1018" title="Dictionary stamping state - DEFAULT By default the engine will fall back to the server-wide configura...">com.pcbsys.nirvana.client.nChannelAttributes::DICTIONARY_STAMPING_DEFAULT</a></code> to configure this channel to fall back to the default (server-wide) configuration setting </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c62320a395c14e8683eae8a6d3204b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setSyncBatchTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether each write to the store will also call sync on the file system to ensure all data is written to the Disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>true or false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f15023ed90a0a15aa3af93b700ffcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setSyncMaxBatchSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether each write to the store will also call sync on the file system to ensure all data is written to the Disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>value between 1 and 1000; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47eacf87cdc3566560e43ad9cd338b69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::pcbsys::nirvana::client::nStoreProperties::setSyncOnEachWrite </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether each write to the store will also call sync on the file system to ensure all data is written to the Disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>true or false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div> <!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  --> <!-- end main -->
</div> <!-- end wrapper -->
<div id="footer">
<div>
Copyright &copy; 2020 Software AG, Darmstadt Germany
and/or Software AG USA, Inc., Reston, VA, United States of America,
and/or their licensors.
<br/>
</div>
</div> <!-- end footer -->
</body>
</html>
