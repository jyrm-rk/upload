<!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>com.pcbsys.nirvana.client.nConstants Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="nirvana.css" />
</head>
<body>
<div id="topbar">
<a href="http://www.universalmessaging.org/"><img id="logo" border="0" src="logo.png"/></a>
</div>
<div class="wrapper">
<div id="main">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>com</b></li><li class="navelem"><b>pcbsys</b></li><li class="navelem"><b>nirvana</b></li><li class="navelem"><a class="el" href="namespacecom_1_1pcbsys_1_1nirvana_1_1client.html">client</a></li><li class="navelem"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html">nConstants</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">com.pcbsys.nirvana.client.nConstants Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is a container for the various constants that affect the behaviour of various Nirvana Client API calls.  
 <a href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acefdd69a3a0b184fdf573f84ea19c0df"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#acefdd69a3a0b184fdf573f84ea19c0df">allowStoreCaching</a> ()</td></tr>
<tr class="memdesc:acefdd69a3a0b184fdf573f84ea19c0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel lookup are cached to avoid subsequent lookups resulting in a server call.  <a href="#acefdd69a3a0b184fdf573f84ea19c0df">More...</a><br/></td></tr>
<tr class="separator:acefdd69a3a0b184fdf573f84ea19c0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088e792b6ed0501302d3b96d06e938a2"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a088e792b6ed0501302d3b96d06e938a2">attemptReconnectAfterAccessChange</a> ()</td></tr>
<tr class="memdesc:a088e792b6ed0501302d3b96d06e938a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked.  <a href="#a088e792b6ed0501302d3b96d06e938a2">More...</a><br/></td></tr>
<tr class="separator:a088e792b6ed0501302d3b96d06e938a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7331812c0f97057c54df1ec7c4e24a"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#adb7331812c0f97057c54df1ec7c4e24a">attemptReconnectImmediately</a> ()</td></tr>
<tr class="memdesc:adb7331812c0f97057c54df1ec7c4e24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once.  <a href="#adb7331812c0f97057c54df1ec7c4e24a">More...</a><br/></td></tr>
<tr class="separator:adb7331812c0f97057c54df1ec7c4e24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2186def1f9a08b2620abc5d704a3e8e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ae2186def1f9a08b2620abc5d704a3e8e">enableDebug</a> (boolean enabled)</td></tr>
<tr class="memdesc:ae2186def1f9a08b2620abc5d704a3e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug flag to true or false.  <a href="#ae2186def1f9a08b2620abc5d704a3e8e">More...</a><br/></td></tr>
<tr class="separator:ae2186def1f9a08b2620abc5d704a3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001f76c7fc3335921e9e858372161124"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a001f76c7fc3335921e9e858372161124">getAccessWaitLimit</a> ()</td></tr>
<tr class="memdesc:a001f76c7fc3335921e9e858372161124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue access wait time.  <a href="#a001f76c7fc3335921e9e858372161124">More...</a><br/></td></tr>
<tr class="separator:a001f76c7fc3335921e9e858372161124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0864b5db9fbdece9dfd2166fd571bd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#abc0864b5db9fbdece9dfd2166fd571bd">getBlockLimit</a> ()</td></tr>
<tr class="memdesc:abc0864b5db9fbdece9dfd2166fd571bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue block wait time.  <a href="#abc0864b5db9fbdece9dfd2166fd571bd">More...</a><br/></td></tr>
<tr class="separator:abc0864b5db9fbdece9dfd2166fd571bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9d24c6d61f2ae46cbf9a15f7b598c8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7b9d24c6d61f2ae46cbf9a15f7b598c8">getConnectionBlockWeighting</a> ()</td></tr>
<tr class="memdesc:a7b9d24c6d61f2ae46cbf9a15f7b598c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue block weighting.  <a href="#a7b9d24c6d61f2ae46cbf9a15f7b598c8">More...</a><br/></td></tr>
<tr class="separator:a7b9d24c6d61f2ae46cbf9a15f7b598c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2597b3418c013c5b459a913302bfe8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8a2597b3418c013c5b459a913302bfe8">getConnectionQueueHighWater</a> ()</td></tr>
<tr class="memdesc:a8a2597b3418c013c5b459a913302bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue high watermark.  <a href="#a8a2597b3418c013c5b459a913302bfe8">More...</a><br/></td></tr>
<tr class="separator:a8a2597b3418c013c5b459a913302bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23839a1036420de46ca65724fe7724d8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a23839a1036420de46ca65724fe7724d8">getConnectionQueueLowWater</a> ()</td></tr>
<tr class="memdesc:a23839a1036420de46ca65724fe7724d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue low watermark.  <a href="#a23839a1036420de46ca65724fe7724d8">More...</a><br/></td></tr>
<tr class="separator:a23839a1036420de46ca65724fe7724d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7120423af6697266ac31751e24fc7410"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7120423af6697266ac31751e24fc7410">getDataGroupQueueSize</a> ()</td></tr>
<tr class="separator:a7120423af6697266ac31751e24fc7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec92cc03711b2a2bd6a8f5cee9653f2e"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aec92cc03711b2a2bd6a8f5cee9653f2e">getEnableAutoGC</a> ()</td></tr>
<tr class="memdesc:aec92cc03711b2a2bd6a8f5cee9653f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client can enable / disable the um code from monitoring and managing the memory.  <a href="#aec92cc03711b2a2bd6a8f5cee9653f2e">More...</a><br/></td></tr>
<tr class="separator:aec92cc03711b2a2bd6a8f5cee9653f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92c6a7d1d42f76a3b5d342c4b7ac99b"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ab92c6a7d1d42f76a3b5d342c4b7ac99b">getEnabledPriorityQueues</a> ()</td></tr>
<tr class="memdesc:ab92c6a7d1d42f76a3b5d342c4b7ac99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether priority queueing is enabled for this client.  <a href="#ab92c6a7d1d42f76a3b5d342c4b7ac99b">More...</a><br/></td></tr>
<tr class="separator:ab92c6a7d1d42f76a3b5d342c4b7ac99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16780b98a9f5520c0eca010c34f0d14e"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a16780b98a9f5520c0eca010c34f0d14e">getEVENTWAIT</a> ()</td></tr>
<tr class="memdesc:a16780b98a9f5520c0eca010c34f0d14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm.  <a href="#a16780b98a9f5520c0eca010c34f0d14e">More...</a><br/></td></tr>
<tr class="separator:a16780b98a9f5520c0eca010c34f0d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfb0c2867668adfc0fb7712053076a8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aacfb0c2867668adfc0fb7712053076a8">getInitialConnectionTimeout</a> ()</td></tr>
<tr class="memdesc:aacfb0c2867668adfc0fb7712053076a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the current value for the Initial socket connect timeout.  <a href="#aacfb0c2867668adfc0fb7712053076a8">More...</a><br/></td></tr>
<tr class="separator:aacfb0c2867668adfc0fb7712053076a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb1fc47e3874491ac1d09d2957c69b5"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a4fb1fc47e3874491ac1d09d2957c69b5">getKeepAliveInterval</a> ()</td></tr>
<tr class="memdesc:a4fb1fc47e3874491ac1d09d2957c69b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value in ms to wait before sending a Keep Alive.  <a href="#a4fb1fc47e3874491ac1d09d2957c69b5">More...</a><br/></td></tr>
<tr class="separator:a4fb1fc47e3874491ac1d09d2957c69b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86298b27047ba72f72f178196c29897d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a86298b27047ba72f72f178196c29897d">getMaxUnackedEvents</a> ()</td></tr>
<tr class="memdesc:a86298b27047ba72f72f178196c29897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of events that can be received by a consumer on a shared named object (shared durable) before the consumer need to acknowledge or rollback.  <a href="#a86298b27047ba72f72f178196c29897d">More...</a><br/></td></tr>
<tr class="separator:a86298b27047ba72f72f178196c29897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64e2cfaf45ef28351eccb564b05130c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ad64e2cfaf45ef28351eccb564b05130c">getPriorityQueueCount</a> ()</td></tr>
<tr class="memdesc:ad64e2cfaf45ef28351eccb564b05130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of queues used for priority messaging.  <a href="#ad64e2cfaf45ef28351eccb564b05130c">More...</a><br/></td></tr>
<tr class="separator:ad64e2cfaf45ef28351eccb564b05130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340d8a8fa0f072d53a682931842569cb"><td class="memItemLeft" align="right" valign="top">static nProxyAuthenticatorHelper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a340d8a8fa0f072d53a682931842569cb">getProxyAuthenticatorHelper</a> ()</td></tr>
<tr class="memdesc:a340d8a8fa0f072d53a682931842569cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the connection helper for proxy connections.  <a href="#a340d8a8fa0f072d53a682931842569cb">More...</a><br/></td></tr>
<tr class="separator:a340d8a8fa0f072d53a682931842569cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b951e9f11b2389b6008c20f897198f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a03b951e9f11b2389b6008c20f897198f">getPushWaitLimit</a> ()</td></tr>
<tr class="memdesc:a03b951e9f11b2389b6008c20f897198f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound publish queue push wait time.  <a href="#a03b951e9f11b2389b6008c20f897198f">More...</a><br/></td></tr>
<tr class="separator:a03b951e9f11b2389b6008c20f897198f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd518035958a5ef12ff1b74077f7c2"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a1edd518035958a5ef12ff1b74077f7c2">getReconnectInterval</a> ()</td></tr>
<tr class="memdesc:a1edd518035958a5ef12ff1b74077f7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately.  <a href="#a1edd518035958a5ef12ff1b74077f7c2">More...</a><br/></td></tr>
<tr class="separator:a1edd518035958a5ef12ff1b74077f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8079d98142e1bac3353ba91e78a3482"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aa8079d98142e1bac3353ba91e78a3482">getSocketReceiveBufferSize</a> ()</td></tr>
<tr class="memdesc:aa8079d98142e1bac3353ba91e78a3482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inbound socket buffer size.  <a href="#aa8079d98142e1bac3353ba91e78a3482">More...</a><br/></td></tr>
<tr class="separator:aa8079d98142e1bac3353ba91e78a3482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407e696017802b47d2fc10661192f3b6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a407e696017802b47d2fc10661192f3b6">getSocketSendBufferSize</a> ()</td></tr>
<tr class="memdesc:a407e696017802b47d2fc10661192f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outbound socket buffer size.  <a href="#a407e696017802b47d2fc10661192f3b6">More...</a><br/></td></tr>
<tr class="separator:a407e696017802b47d2fc10661192f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b186fbfb2e0692abcb039450f1399"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aa01b186fbfb2e0692abcb039450f1399">getSubHighWater</a> ()</td></tr>
<tr class="memdesc:aa01b186fbfb2e0692abcb039450f1399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the subscriber queue high watermark.  <a href="#aa01b186fbfb2e0692abcb039450f1399">More...</a><br/></td></tr>
<tr class="separator:aa01b186fbfb2e0692abcb039450f1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceb78f35b8b4c62be9e444f5b6bd895"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#adceb78f35b8b4c62be9e444f5b6bd895">getSubLowWater</a> ()</td></tr>
<tr class="memdesc:adceb78f35b8b4c62be9e444f5b6bd895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the subscriber queue low watermark.  <a href="#adceb78f35b8b4c62be9e444f5b6bd895">More...</a><br/></td></tr>
<tr class="separator:adceb78f35b8b4c62be9e444f5b6bd895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776de1152b7519af6965072b17830508"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a776de1152b7519af6965072b17830508">getSupportExtendedFiltering</a> ()</td></tr>
<tr class="memdesc:a776de1152b7519af6965072b17830508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether extended filtering is supported.  <a href="#a776de1152b7519af6965072b17830508">More...</a><br/></td></tr>
<tr class="separator:a776de1152b7519af6965072b17830508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a32a693a75d9329988f81f71a407d0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af9a32a693a75d9329988f81f71a407d0">getThreadReuseQueueSize</a> ()</td></tr>
<tr class="memdesc:af9a32a693a75d9329988f81f71a407d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the reusable threads pool.  <a href="#af9a32a693a75d9329988f81f71a407d0">More...</a><br/></td></tr>
<tr class="separator:af9a32a693a75d9329988f81f71a407d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b9337e7a884f3dc05bd427a83ae35c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a21b9337e7a884f3dc05bd427a83ae35c">getWriteHandlerType</a> ()</td></tr>
<tr class="memdesc:a21b9337e7a884f3dc05bd427a83ae35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current write handling mode that the client is using.  <a href="#a21b9337e7a884f3dc05bd427a83ae35c">More...</a><br/></td></tr>
<tr class="separator:a21b9337e7a884f3dc05bd427a83ae35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab081db9a4d3c95836c7fc372b98970e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ab081db9a4d3c95836c7fc372b98970e6">honour3rdPartyCookies</a> (boolean flag)</td></tr>
<tr class="memdesc:ab081db9a4d3c95836c7fc372b98970e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set the underlying nhp(s) drivers will extract and use the Set-Cookie response from an intermediate proxy.  <a href="#ab081db9a4d3c95836c7fc372b98970e6">More...</a><br/></td></tr>
<tr class="separator:ab081db9a4d3c95836c7fc372b98970e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d48efef04572908929c2546f6ef6e5"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a38d48efef04572908929c2546f6ef6e5">isDebugEnabled</a> ()</td></tr>
<tr class="memdesc:a38d48efef04572908929c2546f6ef6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the debug flag is set to true or false.  <a href="#a38d48efef04572908929c2546f6ef6e5">More...</a><br/></td></tr>
<tr class="separator:a38d48efef04572908929c2546f6ef6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa379c04fd13ead6d65b7df0032ab2915"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aa379c04fd13ead6d65b7df0032ab2915">isHonouring3rdPartyCookies</a> ()</td></tr>
<tr class="separator:aa379c04fd13ead6d65b7df0032ab2915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9470db2a5856c5cd2e82d8aa458293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9470db2a5856c5cd2e82d8aa458293"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a2a9470db2a5856c5cd2e82d8aa458293">resetCertificateAlias</a> ()</td></tr>
<tr class="memdesc:a2a9470db2a5856c5cd2e82d8aa458293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the certificate alias to be used for SSL connections to the one selected by default by the key manager. <br/></td></tr>
<tr class="separator:a2a9470db2a5856c5cd2e82d8aa458293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10751d9010551452b6b89a1465806f12"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a10751d9010551452b6b89a1465806f12">setAccessWaitLimit</a> (int p_accessWait)</td></tr>
<tr class="memdesc:a10751d9010551452b6b89a1465806f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue access wait time.  <a href="#a10751d9010551452b6b89a1465806f12">More...</a><br/></td></tr>
<tr class="separator:a10751d9010551452b6b89a1465806f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cb1a5565bf2d0e3a54f3416c4e52a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a59cb1a5565bf2d0e3a54f3416c4e52a9">setBlockLimit</a> (int p_blockWait)</td></tr>
<tr class="memdesc:a59cb1a5565bf2d0e3a54f3416c4e52a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue block wait time.  <a href="#a59cb1a5565bf2d0e3a54f3416c4e52a9">More...</a><br/></td></tr>
<tr class="separator:a59cb1a5565bf2d0e3a54f3416c4e52a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe3d429c81aa7066b349aa1bfe05d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af1fe3d429c81aa7066b349aa1bfe05d2">setCertificateAlias</a> (String alias)</td></tr>
<tr class="memdesc:af1fe3d429c81aa7066b349aa1bfe05d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the certificate alias to be used for SSL connections, overrides the default selection of the key manager.  <a href="#af1fe3d429c81aa7066b349aa1bfe05d2">More...</a><br/></td></tr>
<tr class="separator:af1fe3d429c81aa7066b349aa1bfe05d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae511904fb4b4769f0347b289794d5a49"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ae511904fb4b4769f0347b289794d5a49">setClientLogLevel</a> (int level)</td></tr>
<tr class="memdesc:ae511904fb4b4769f0347b289794d5a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the log level for the client.  <a href="#ae511904fb4b4769f0347b289794d5a49">More...</a><br/></td></tr>
<tr class="separator:ae511904fb4b4769f0347b289794d5a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e86d96bc779b2ca9854917052e6a86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a94e86d96bc779b2ca9854917052e6a86">setConnectionBlockWeighting</a> (int blockWeighting)</td></tr>
<tr class="memdesc:a94e86d96bc779b2ca9854917052e6a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue block weighting.  <a href="#a94e86d96bc779b2ca9854917052e6a86">More...</a><br/></td></tr>
<tr class="separator:a94e86d96bc779b2ca9854917052e6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b1b45011d5f17c64fabdb920e375a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a02b1b45011d5f17c64fabdb920e375a4">setConnectionQueueHighWater</a> (int high)</td></tr>
<tr class="memdesc:a02b1b45011d5f17c64fabdb920e375a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue high watermark.  <a href="#a02b1b45011d5f17c64fabdb920e375a4">More...</a><br/></td></tr>
<tr class="separator:a02b1b45011d5f17c64fabdb920e375a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ced271567eac4e38ea12c47bc72cc22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a5ced271567eac4e38ea12c47bc72cc22">setConnectionQueueLowWater</a> (int low)</td></tr>
<tr class="memdesc:a5ced271567eac4e38ea12c47bc72cc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue low watermark.  <a href="#a5ced271567eac4e38ea12c47bc72cc22">More...</a><br/></td></tr>
<tr class="separator:a5ced271567eac4e38ea12c47bc72cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d457cbf8bfa93594aa619b86ae51e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aa7d457cbf8bfa93594aa619b86ae51e7">setDataGroupQueueSize</a> (int queueSize)</td></tr>
<tr class="memdesc:aa7d457cbf8bfa93594aa619b86ae51e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of events that are still to ve delivered to the client.  <a href="#aa7d457cbf8bfa93594aa619b86ae51e7">More...</a><br/></td></tr>
<tr class="separator:aa7d457cbf8bfa93594aa619b86ae51e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636b62aaad4e62110eca99574f102c65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a636b62aaad4e62110eca99574f102c65">setDefaultStoreCapacity</a> (int cap)</td></tr>
<tr class="memdesc:a636b62aaad4e62110eca99574f102c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity that will be used for any channels or queues created within this JVM.  <a href="#a636b62aaad4e62110eca99574f102c65">More...</a><br/></td></tr>
<tr class="separator:a636b62aaad4e62110eca99574f102c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668ebdd4cb93a65184afbb9470089f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a6668ebdd4cb93a65184afbb9470089f3">setDefaultStoreTTL</a> (int ttl)</td></tr>
<tr class="memdesc:a6668ebdd4cb93a65184afbb9470089f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ttl that will be used for any channels or queues created within this JVM.  <a href="#a6668ebdd4cb93a65184afbb9470089f3">More...</a><br/></td></tr>
<tr class="separator:a6668ebdd4cb93a65184afbb9470089f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af5edaae21e58187dc0f87e82cbe79b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a5af5edaae21e58187dc0f87e82cbe79b">setEnableAutoGC</a> (boolean flag)</td></tr>
<tr class="memdesc:a5af5edaae21e58187dc0f87e82cbe79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client will monitor the memory usage within the JVM, if it exceeds 85% used it will attempt to free memory by calling gc().  <a href="#a5af5edaae21e58187dc0f87e82cbe79b">More...</a><br/></td></tr>
<tr class="separator:a5af5edaae21e58187dc0f87e82cbe79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e68402e3b59a4a7179eb010173aa4a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a00e68402e3b59a4a7179eb010173aa4a">setEnabledPriorityQueues</a> (boolean enabled)</td></tr>
<tr class="memdesc:a00e68402e3b59a4a7179eb010173aa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the usage of priority queues for this client.  <a href="#a00e68402e3b59a4a7179eb010173aa4a">More...</a><br/></td></tr>
<tr class="separator:a00e68402e3b59a4a7179eb010173aa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fcdf6ce572ae7867b082c89aed051d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a49fcdf6ce572ae7867b082c89aed051d">setEVENTWAIT</a> (long newval)</td></tr>
<tr class="memdesc:a49fcdf6ce572ae7867b082c89aed051d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm.  <a href="#a49fcdf6ce572ae7867b082c89aed051d">More...</a><br/></td></tr>
<tr class="separator:a49fcdf6ce572ae7867b082c89aed051d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04df09181ab74d7d84e7ffd06673634"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ae04df09181ab74d7d84e7ffd06673634">setInitialConnectionTimeout</a> (int timeout)</td></tr>
<tr class="memdesc:ae04df09181ab74d7d84e7ffd06673634"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the current value for the Initial socket connect timeout.  <a href="#ae04df09181ab74d7d84e7ffd06673634">More...</a><br/></td></tr>
<tr class="separator:ae04df09181ab74d7d84e7ffd06673634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eacce4d0c9717d7cb94747ee5512e4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a6eacce4d0c9717d7cb94747ee5512e4e">setKeepAliveInterval</a> (long newVal)</td></tr>
<tr class="memdesc:a6eacce4d0c9717d7cb94747ee5512e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value in ms to wait before sending a Keep Alive.  <a href="#a6eacce4d0c9717d7cb94747ee5512e4e">More...</a><br/></td></tr>
<tr class="separator:a6eacce4d0c9717d7cb94747ee5512e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da3779b6ffdd392bcc81b72013d70e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a2da3779b6ffdd392bcc81b72013d70e7">setMaxUnackedEvents</a> (int maxUnackedEvents)</td></tr>
<tr class="memdesc:a2da3779b6ffdd392bcc81b72013d70e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of events that can be received by a consumer on a shared named object (shared durable) before the consumer need to acknowledge or rollback.  <a href="#a2da3779b6ffdd392bcc81b72013d70e7">More...</a><br/></td></tr>
<tr class="separator:a2da3779b6ffdd392bcc81b72013d70e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa065bc2720e0b0004b561dd1b2ba3e9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aa065bc2720e0b0004b561dd1b2ba3e9b">setPermittedKeepAlivesMissed</a> (int kas)</td></tr>
<tr class="memdesc:aa065bc2720e0b0004b561dd1b2ba3e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of keep alives that the client can miss before closing the connection.  <a href="#aa065bc2720e0b0004b561dd1b2ba3e9b">More...</a><br/></td></tr>
<tr class="separator:aa065bc2720e0b0004b561dd1b2ba3e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdcce6de832d5894fff18a9ab902cb0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8cdcce6de832d5894fff18a9ab902cb0">setPriorityQueueCount</a> (int queueCount)</td></tr>
<tr class="memdesc:a8cdcce6de832d5894fff18a9ab902cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of queues to use when allocating priority.  <a href="#a8cdcce6de832d5894fff18a9ab902cb0">More...</a><br/></td></tr>
<tr class="separator:a8cdcce6de832d5894fff18a9ab902cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6009faf41c7c4aa54360e539c08964"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a3e6009faf41c7c4aa54360e539c08964">setProxyAuthenticatorHelper</a> (nProxyAuthenticatorHelper helper)</td></tr>
<tr class="memdesc:a3e6009faf41c7c4aa54360e539c08964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the authentication helper for proxy connections.  <a href="#a3e6009faf41c7c4aa54360e539c08964">More...</a><br/></td></tr>
<tr class="separator:a3e6009faf41c7c4aa54360e539c08964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789e4cbabee644c6a377eb5f957a504b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a789e4cbabee644c6a377eb5f957a504b">setPushWaitLimit</a> (int p_pushWait)</td></tr>
<tr class="memdesc:a789e4cbabee644c6a377eb5f957a504b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the outbound publish queue push wait time.  <a href="#a789e4cbabee644c6a377eb5f957a504b">More...</a><br/></td></tr>
<tr class="separator:a789e4cbabee644c6a377eb5f957a504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377b028344c35a418f662f6798c071b3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a377b028344c35a418f662f6798c071b3">setReconnectAfterAccessChange</a> (boolean recon)</td></tr>
<tr class="memdesc:a377b028344c35a418f662f6798c071b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked.  <a href="#a377b028344c35a418f662f6798c071b3">More...</a><br/></td></tr>
<tr class="separator:a377b028344c35a418f662f6798c071b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98107a44452d2159274ea8be3cf248e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ac98107a44452d2159274ea8be3cf248e">setReconnectImmediately</a> (boolean recon)</td></tr>
<tr class="memdesc:ac98107a44452d2159274ea8be3cf248e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once.  <a href="#ac98107a44452d2159274ea8be3cf248e">More...</a><br/></td></tr>
<tr class="separator:ac98107a44452d2159274ea8be3cf248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d76a82ad613088cd69742e3bde91b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a85d76a82ad613088cd69742e3bde91b5">setReconnectInterval</a> (long interval)</td></tr>
<tr class="memdesc:a85d76a82ad613088cd69742e3bde91b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately.  <a href="#a85d76a82ad613088cd69742e3bde91b5">More...</a><br/></td></tr>
<tr class="separator:a85d76a82ad613088cd69742e3bde91b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf5c3f486f350ace2daaa7aaa5d08ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a0bf5c3f486f350ace2daaa7aaa5d08ed">setSocketReceiveBufferSize</a> (int bufSize)</td></tr>
<tr class="memdesc:a0bf5c3f486f350ace2daaa7aaa5d08ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the inbound socket buffer size.  <a href="#a0bf5c3f486f350ace2daaa7aaa5d08ed">More...</a><br/></td></tr>
<tr class="separator:a0bf5c3f486f350ace2daaa7aaa5d08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb91fd9a701ca087611f10a51742e55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a0bb91fd9a701ca087611f10a51742e55">setSocketSendBufferSize</a> (int bufSize)</td></tr>
<tr class="memdesc:a0bb91fd9a701ca087611f10a51742e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the outbound socket buffer size.  <a href="#a0bb91fd9a701ca087611f10a51742e55">More...</a><br/></td></tr>
<tr class="separator:a0bb91fd9a701ca087611f10a51742e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5794616924dacee6c4e5ef96c6115"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a3ae5794616924dacee6c4e5ef96c6115">setSubHighWater</a> (int high)</td></tr>
<tr class="memdesc:a3ae5794616924dacee6c4e5ef96c6115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subscriber queue high watermark.  <a href="#a3ae5794616924dacee6c4e5ef96c6115">More...</a><br/></td></tr>
<tr class="separator:a3ae5794616924dacee6c4e5ef96c6115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61d26e6228a8c852e308865385428ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ad61d26e6228a8c852e308865385428ac">setSubLowWater</a> (int low)</td></tr>
<tr class="memdesc:ad61d26e6228a8c852e308865385428ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subscriber queue low watermark.  <a href="#ad61d26e6228a8c852e308865385428ac">More...</a><br/></td></tr>
<tr class="separator:ad61d26e6228a8c852e308865385428ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af193fba4557aaa37bbdcd8006ae1eea3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af193fba4557aaa37bbdcd8006ae1eea3">setSupportExtendedFiltering</a> (boolean flag)</td></tr>
<tr class="memdesc:af193fba4557aaa37bbdcd8006ae1eea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client can enable / disable extended filtering *.  <a href="#af193fba4557aaa37bbdcd8006ae1eea3">More...</a><br/></td></tr>
<tr class="separator:af193fba4557aaa37bbdcd8006ae1eea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79224b58955b207a8ad5fce8012ef502"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a79224b58955b207a8ad5fce8012ef502">setThreadReuseQueueSize</a> (int size)</td></tr>
<tr class="memdesc:a79224b58955b207a8ad5fce8012ef502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the reusable threads pool.  <a href="#a79224b58955b207a8ad5fce8012ef502">More...</a><br/></td></tr>
<tr class="separator:a79224b58955b207a8ad5fce8012ef502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1355e9ffde4f566c32777ce759fcbb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a1e1355e9ffde4f566c32777ce759fcbb">setTraceFolderLogSize</a> (int size)  throws nIllegalArgumentException </td></tr>
<tr class="memdesc:a1e1355e9ffde4f566c32777ce759fcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the directory containing all trace log files.  <a href="#a1e1355e9ffde4f566c32777ce759fcbb">More...</a><br/></td></tr>
<tr class="separator:a1e1355e9ffde4f566c32777ce759fcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb4b2c7dacffef040cfb0bc6e49503e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aebb4b2c7dacffef040cfb0bc6e49503e">setTraceLoggerPath</a> (String logPath)  throws nIllegalArgumentException </td></tr>
<tr class="memdesc:aebb4b2c7dacffef040cfb0bc6e49503e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to a location where per store logs will be stored.  <a href="#aebb4b2c7dacffef040cfb0bc6e49503e">More...</a><br/></td></tr>
<tr class="separator:aebb4b2c7dacffef040cfb0bc6e49503e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afcd4edb45e7a756764761e32b0734"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#af6afcd4edb45e7a756764761e32b0734">setTraceStoreLogLevel</a> (StoreLogConfigLevel logLevel)  throws IllegalStateException </td></tr>
<tr class="memdesc:af6afcd4edb45e7a756764761e32b0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the client store tracing log level.  <a href="#af6afcd4edb45e7a756764761e32b0734">More...</a><br/></td></tr>
<tr class="separator:af6afcd4edb45e7a756764761e32b0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6d43d2dbdbb1ee2b561891f80c0b70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#aaa6d43d2dbdbb1ee2b561891f80c0b70">setTraceStoreLogSize</a> (int size)  throws nIllegalArgumentException </td></tr>
<tr class="memdesc:aaa6d43d2dbdbb1ee2b561891f80c0b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of a single per store log file.  <a href="#aaa6d43d2dbdbb1ee2b561891f80c0b70">More...</a><br/></td></tr>
<tr class="separator:aaa6d43d2dbdbb1ee2b561891f80c0b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d69f07c52b9187331b7f71d5e53619a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a2d69f07c52b9187331b7f71d5e53619a">setTraceStores</a> (String traceStores)</td></tr>
<tr class="memdesc:a2d69f07c52b9187331b7f71d5e53619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the list of stores(channels or queues) to be enabled for trace logging.  <a href="#a2d69f07c52b9187331b7f71d5e53619a">More...</a><br/></td></tr>
<tr class="separator:a2d69f07c52b9187331b7f71d5e53619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be85c6d05489d3a6709509d2350e890"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a7be85c6d05489d3a6709509d2350e890">setWriteHandlerType</a> (int type)</td></tr>
<tr class="memdesc:a7be85c6d05489d3a6709509d2350e890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to specify the type of write handling that the client code will employ.  <a href="#a7be85c6d05489d3a6709509d2350e890">More...</a><br/></td></tr>
<tr class="separator:a7be85c6d05489d3a6709509d2350e890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3f716bb78bda8cd558004f678ac15e"><td class="memItemLeft" align="right" valign="top">static boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8a3f716bb78bda8cd558004f678ac15e">stripJMSMessageIdPrefix</a> ()</td></tr>
<tr class="memdesc:a8a3f716bb78bda8cd558004f678ac15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unused.  <a href="#a8a3f716bb78bda8cd558004f678ac15e">More...</a><br/></td></tr>
<tr class="separator:a8a3f716bb78bda8cd558004f678ac15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8dc9ff059c59ea8809b89511f812f4f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc9ff059c59ea8809b89511f812f4f9"></a>
static final long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a8dc9ff059c59ea8809b89511f812f4f9">CHAN_DELETED_EVENT_ID</a> = -2</td></tr>
<tr class="memdesc:a8dc9ff059c59ea8809b89511f812f4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event ID is used when a delete store occurs whilst having an asynchronous consumer connected to a store. <br/></td></tr>
<tr class="separator:a8dc9ff059c59ea8809b89511f812f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161e9079a8f626897978b475fb860d31"><td class="memItemLeft" align="right" valign="top">static final String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a161e9079a8f626897978b475fb860d31">HS_RELEASE_VERSION_PARAM</a> = &quot;hsReleaseVersion&quot;</td></tr>
<tr class="memdesc:a161e9079a8f626897978b475fb860d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional horizontal scalability url parameter which configures the Universal Messaging connection protocol version/release to use when connecting to a horizontal scalability group of servers.  <a href="#a161e9079a8f626897978b475fb860d31">More...</a><br/></td></tr>
<tr class="separator:a161e9079a8f626897978b475fb860d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79cd11efee15c5f011f7eecf380dcf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae79cd11efee15c5f011f7eecf380dcf8"></a>
static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#ae79cd11efee15c5f011f7eecf380dcf8">sDirectWriteHandler</a> = fConnectionSettings.sDirectWriteHandler</td></tr>
<tr class="memdesc:ae79cd11efee15c5f011f7eecf380dcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This write handler only uses a direct write method to the network layer, this reduces latencies but may increase the cpu used. <br/></td></tr>
<tr class="separator:ae79cd11efee15c5f011f7eecf380dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527d2fe86ab73d4c8d3ae0b83c8deabb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a527d2fe86ab73d4c8d3ae0b83c8deabb"></a>
static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a527d2fe86ab73d4c8d3ae0b83c8deabb">sQueuedWriteHandler</a> = fConnectionSettings.sBufferedWriteHandler</td></tr>
<tr class="memdesc:a527d2fe86ab73d4c8d3ae0b83c8deabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This write handler implements the older method of buffering and sending requests and flushing once the queue was emtpy this maximised the network usage but latency can suffer. <br/></td></tr>
<tr class="separator:a527d2fe86ab73d4c8d3ae0b83c8deabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65695b182b122305e668fc61b0786d2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65695b182b122305e668fc61b0786d2a"></a>
static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_constants.html#a65695b182b122305e668fc61b0786d2a">sStandardWriteHandler</a> = fConnectionSettings.sPeakWriteHandler</td></tr>
<tr class="memdesc:a65695b182b122305e668fc61b0786d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This write handler uses a combination of direct writing and buffered writing to the network depending on client event load. <br/></td></tr>
<tr class="separator:a65695b182b122305e668fc61b0786d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a container for the various constants that affect the behaviour of various Nirvana Client API calls. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acefdd69a3a0b184fdf573f84ea19c0df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.allowStoreCaching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Channel lookup are cached to avoid subsequent lookups resulting in a server call. </p>
<p>Defaults to true. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>since 10.1 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean flag indicating the current state </dd></dl>

</div>
</div>
<a class="anchor" id="a088e792b6ed0501302d3b96d06e938a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.attemptReconnectAfterAccessChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked. </p>
<p>By default, the <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will not reconnect after one of these incidents, and a manual restart would need to be initiated</p>
<dl class="section return"><dt>Returns</dt><dd>true if reconnect is enabled after realm ACL subject revocation </dd></dl>

</div>
</div>
<a class="anchor" id="adb7331812c0f97057c54df1ec7c4e24a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.attemptReconnectImmediately </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once. </p>
<dl class="section return"><dt>Returns</dt><dd>true if reconnect immediately is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="ae2186def1f9a08b2620abc5d704a3e8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.enableDebug </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the debug flag to true or false. </p>
<p>If true verbose logging will occur for connections to the realm server </p>
<p>By default, debug is not enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>- whether debug is enabled (true) or disabled (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a001f76c7fc3335921e9e858372161124"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getAccessWaitLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue access wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that the queue cannot be accessed. This period is called the block access time</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue access wait </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc0864b5db9fbdece9dfd2166fd571bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getBlockLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue block wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. This period is called the block wait time</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue block wait </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b9d24c6d61f2ae46cbf9a15f7b598c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getConnectionBlockWeighting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue block weighting. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. The connection block weighting is a value that is applied to the block wait value in order to control the frequency of these notifications.</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue block weighting </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8a2597b3418c013c5b459a913302bfe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getConnectionQueueHighWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue high watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>the outbound connection queue high water mark </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a23839a1036420de46ca65724fe7724d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getConnectionQueueLowWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue low watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>the outbound connection queue low water mark </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7120423af6697266ac31751e24fc7410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getDataGroupQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current data group event queue size </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>10.0 Unused function </dd></dl>

</div>
</div>
<a class="anchor" id="aec92cc03711b2a2bd6a8f5cee9653f2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.getEnableAutoGC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The client can enable / disable the um code from monitoring and managing the memory. </p>
<dl class="section return"><dt>Returns</dt><dd>a boolean flag indicating the current state </dd></dl>

</div>
</div>
<a class="anchor" id="ab92c6a7d1d42f76a3b5d342c4b7ac99b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.getEnabledPriorityQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether priority queueing is enabled for this client. </p>
<dl class="section return"><dt>Returns</dt><dd>true if priority queueing is enabled for this client, false otherwise. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>This method is deprecated since 10.3. Priority queues are always enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a16780b98a9f5520c0eca010c34f0d14e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long com.pcbsys.nirvana.client.nConstants.getEVENTWAIT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm. </p>
<p>The default value is 60 secs and typically if you get a <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a> the cause would be: </p>
<ol type="1">
<li>There is a protocol mismatch between the client library in use and server you are connected to. </li>
</ol>
<ol type="1">
<li>The realm is really so busy that has not managed to respond to your request within the specified maximum interval. </li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>a long specifying the maximum wait time for a protocol request (in ms) </dd></dl>

</div>
</div>
<a class="anchor" id="aacfb0c2867668adfc0fb7712053076a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getInitialConnectionTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the current value for the Initial socket connect timeout. </p>
<p>This timeout is specified in the actual underlying Socket connect, and enables connections made to non existent or unreachable hosts to be returned within a configurable timeframe, rather than relying on the underlying JVM and OS timeout value</p>
<dl class="section return"><dt>Returns</dt><dd>the socket connect timeout value, default is 30000ms </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb1fc47e3874491ac1d09d2957c69b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long com.pcbsys.nirvana.client.nConstants.getKeepAliveInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value in ms to wait before sending a Keep Alive. </p>
<p>This is relevant to the local JVM only. </p>

</div>
</div>
<a class="anchor" id="a86298b27047ba72f72f178196c29897d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getMaxUnackedEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of events that can be received by a consumer on a shared named object (shared durable) before the consumer need to acknowledge or rollback. </p>
<p>The default value is 10. </p>

</div>
</div>
<a class="anchor" id="ad64e2cfaf45ef28351eccb564b05130c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getPriorityQueueCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of queues used for priority messaging. </p>
<p>If priority messaging is disabled, this method will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of queues used for priority messaging. This value is between 0 and 10. </dd></dl>

</div>
</div>
<a class="anchor" id="a340d8a8fa0f072d53a682931842569cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static nProxyAuthenticatorHelper com.pcbsys.nirvana.client.nConstants.getProxyAuthenticatorHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the connection helper for proxy connections. </p>
<p>This will return the last value passed to setProxyAuthenticatorHelper</p>
<dl class="section return"><dt>Returns</dt><dd>nProxyAuthenticatorHelper the helper for proxy connections. </dd></dl>

</div>
</div>
<a class="anchor" id="a03b951e9f11b2389b6008c20f897198f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getPushWaitLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outbound publish queue push wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that events cannot be pushed to the queue. This period is called the push wait time</p>
<dl class="section return"><dt>Returns</dt><dd>the connection queue push wait </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1edd518035958a5ef12ff1b74077f7c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long com.pcbsys.nirvana.client.nConstants.getReconnectInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>true if reconnect immediately is enabled </dd></dl>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa8079d98142e1bac3353ba91e78a3482"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getSocketReceiveBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inbound socket buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes for the inbound buffer size </dd></dl>

</div>
</div>
<a class="anchor" id="a407e696017802b47d2fc10661192f3b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getSocketSendBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the outbound socket buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes for the outbound buffer size </dd></dl>

</div>
</div>
<a class="anchor" id="aa01b186fbfb2e0692abcb039450f1399"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getSubHighWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the subscriber queue high watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>an int specifiying the number of events to be used as a queue high watermark </dd></dl>

</div>
</div>
<a class="anchor" id="adceb78f35b8b4c62be9e444f5b6bd895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getSubLowWater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the subscriber queue low watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="section return"><dt>Returns</dt><dd>an int specifiying the number of events to be used as a queue low watermark </dd></dl>

</div>
</div>
<a class="anchor" id="a776de1152b7519af6965072b17830508"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.getSupportExtendedFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether extended filtering is supported. </p>
<dl class="section return"><dt>Returns</dt><dd>a boolean flag indicating the current state </dd></dl>

</div>
</div>
<a class="anchor" id="af9a32a693a75d9329988f81f71a407d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getThreadReuseQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the reusable threads pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the reusable threads pool </dd></dl>

</div>
</div>
<a class="anchor" id="a21b9337e7a884f3dc05bd427a83ae35c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int com.pcbsys.nirvana.client.nConstants.getWriteHandlerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current write handling mode that the client is using. </p>
<dl class="section return"><dt>Returns</dt><dd>an int of either sStandardWriteHandler or sDirectWriteHandler </dd></dl>

</div>
</div>
<a class="anchor" id="ab081db9a4d3c95836c7fc372b98970e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.honour3rdPartyCookies </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set the underlying nhp(s) drivers will extract and use the Set-Cookie response from an intermediate proxy. </p>
<p>Useful for load balancers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>- Enable or Disable the use of the HTTP Cookie header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d48efef04572908929c2546f6ef6e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.isDebugEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the debug flag is set to true or false. </p>
<p>By default, debug is not enabled</p>
<dl class="section return"><dt>Returns</dt><dd>whether debug is enabled (true) or disabled (false) </dd></dl>

</div>
</div>
<a class="anchor" id="aa379c04fd13ead6d65b7df0032ab2915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.isHonouring3rdPartyCookies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current state of the http cookie header use </dd></dl>

</div>
</div>
<a class="anchor" id="a10751d9010551452b6b89a1465806f12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setAccessWaitLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_accessWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue access wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that the queue cannot be accessed. This period is called the block access time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_accessWait</td><td>the connection queue access wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a59cb1a5565bf2d0e3a54f3416c4e52a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setBlockLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_blockWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue block wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. This period is called the block wait time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_blockWait</td><td>the connection queue block wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1fe3d429c81aa7066b349aa1bfe05d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setCertificateAlias </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the certificate alias to be used for SSL connections, overrides the default selection of the key manager. </p>
<p>If the specified alias is not found, the standrd key manager selection is used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>the alias name of the certificate to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae511904fb4b4769f0347b289794d5a49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setClientLogLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the log level for the client. </p>
<p>All Nirvana client api code contains useful logging messages. The messages are set at specific levels from 0-7. This method allows you to choose what log level you wish to see. Setting to log level 0 will provide verbose output, whereas level 7 will be fairly quiet. </p>
<p>By default, these messages will be sent to System.out</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the log level you wish to set the client application to for nirvana messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94e86d96bc779b2ca9854917052e6a86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setConnectionBlockWeighting </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockWeighting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue block weighting. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a configurable period. The connection block weighting is a value that is applied to the block wait value in order to control the frequency of these notifications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockWeighting</td><td>the connection queue block weighting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a02b1b45011d5f17c64fabdb920e375a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setConnectionQueueHighWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue high watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>the outbound connection queue high water mark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5ced271567eac4e38ea12c47bc72cc22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setConnectionQueueLowWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue low watermark. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>the outbound connection queue low water mark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa7d457cbf8bfa93594aa619b86ae51e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setDataGroupQueueSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of events that are still to ve delivered to the client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueSize</td><td>number of events that the queue will hold before blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>10.0 Unused function </dd></dl>

</div>
</div>
<a class="anchor" id="a636b62aaad4e62110eca99574f102c65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setDefaultStoreCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity that will be used for any channels or queues created within this JVM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>the capacity to set on the channels / queues </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6668ebdd4cb93a65184afbb9470089f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setDefaultStoreTTL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the ttl that will be used for any channels or queues created within this JVM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttl</td><td>the ttl to set on the channels / queues </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5af5edaae21e58187dc0f87e82cbe79b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setEnableAutoGC </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The client will monitor the memory usage within the JVM, if it exceeds 85% used it will attempt to free memory by calling gc(). </p>
<p>If this is not required then, by calling this function, this behaviour is disabled. Please note that the memory management and OOME that may arise needs to be handled by the client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>- boolean flag indicating the required functionality </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00e68402e3b59a4a7179eb010173aa4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setEnabledPriorityQueues </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the usage of priority queues for this client. </p>
<p>This will give delivery preference to messages marked high priority for this client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>boolean true will enable priority queueing for this client, false will disable it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>This method is deprecated since 10.3. Priority queues are always enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a49fcdf6ce572ae7867b082c89aed051d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setEVENTWAIT </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the maximum time the client API will wait for a response to a specific request from the Nirvana realm. </p>
<p>The default value is 60 secs and typically if you get a <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_request_timed_out_exception.html" title="When the maximum time the client API will wait for a response to a specific request from the Nirvana ...">nRequestTimedOutException</a> the cause would be: </p>
<ol type="1">
<li>There is a protocol mismatch between the client library in use and server you are connected to. </li>
</ol>
<ol type="1">
<li>The realm is really so busy that has not managed to respond to your request within the specified maximum interval. </li>
</ol>
<p>Calling this method will only have effect on the local JVM. Alternatively if you change this value through on the realm configuration using the Admin API, all subsequent Nirvana clients that connect will be affected. </p>

</div>
</div>
<a class="anchor" id="ae04df09181ab74d7d84e7ffd06673634"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setInitialConnectionTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets the current value for the Initial socket connect timeout. </p>
<p>This timeout is specified in the actual underlying Socket connect, and enables connections made to non existent or unreachable hosts to be returned within a configurable timeframe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the socket connect timeout value to be set, default is 30000ms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eacce4d0c9717d7cb94747ee5512e4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setKeepAliveInterval </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value in ms to wait before sending a Keep Alive. </p>
<p>This is applied to the local JVM only and is NOT sent to the realm. </p>

</div>
</div>
<a class="anchor" id="a2da3779b6ffdd392bcc81b72013d70e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setMaxUnackedEvents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxUnackedEvents</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of events that can be received by a consumer on a shared named object (shared durable) before the consumer need to acknowledge or rollback. </p>
<p>The default value is 10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxUnackedEvents</td><td>the maximum number of events that a consumer can have unacknowledged at one time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa065bc2720e0b0004b561dd1b2ba3e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setPermittedKeepAlivesMissed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of keep alives that the client can miss before closing the connection. </p>
<p>If 0, the client does not check for any missed keep alives from the server and will continue sending its own keep alive events, until the connection is detected as lost. If &gt; 0, say 1, when the client has not received a message for 1 X the KeepAlive time + 20000ms, the underlying connection will be closed by the client and reconnection will be attempted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kas</td><td>Number of keep alive messages the client will miss before determining the connection as broken </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cdcce6de832d5894fff18a9ab902cb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setPriorityQueueCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of queues to use when allocating priority. </p>
<p>This can be a number between 1 and 10. The number of queues control how priority is arranged, smaller queue counts will coalese priority bands. For example, a queue count of 5 will result in priority 1 and 2, 3 and 4, 5 and 6, 7 and 8, 9 and 10 grouped together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueCount</td><td>The number of queues to use for priority allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if the supplied integer is not between 1 and 10, then this method will throw an IllegalArgumentException </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e6009faf41c7c4aa54360e539c08964"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setProxyAuthenticatorHelper </td>
          <td>(</td>
          <td class="paramtype">nProxyAuthenticatorHelper&#160;</td>
          <td class="paramname"><em>helper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the authentication helper for proxy connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">helper</td><td>The helper to use for proxy connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a789e4cbabee644c6a377eb5f957a504b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setPushWaitLimit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p_pushWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the outbound publish queue push wait time. </p>
<p>Each Nirvana session that sends events to the server (e.g. publishers) place events into an outbound queue to be sent to the server. When the queue reaches the high watermark the queue is unavailable to the client session until the queue reaches it's low water mark, i.e. the events are delivered to the server. When the low water mark is reached the queue is automatically resumed. </p>
<p>When an outbound queue becomes blocked (unavailable) it is possible to become notified after a period of time that events cannot be pushed to the queue. This period is called the push wait time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_pushWait</td><td>the connection queue push wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="interfacecom_1_1pcbsys_1_1nirvana_1_1client_1_1n_connection_queue_listener.html" title="This interface should be implemented by classes wishing to register to receive asynchronous notificat...">com.pcbsys.nirvana.client.nConnectionQueueListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a377b028344c35a418f662f6798c071b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setReconnectAfterAccessChange </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>recon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to reconnect to the realm after the realm ACL has been revoked. </p>
<p>By default, the <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will not reconnect after one of these incidents, and a manual restart would need to be initiated</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recon</td><td>true - will reconnect continually until successful, false, will disabled reconnect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac98107a44452d2159274ea8be3cf248e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setReconnectImmediately </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>recon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether a nirvana <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> will attempt to immediately reconnect or whether reconnection attempts will back off over time to prevent a network storm where multiple re-connections can occur all at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recon</td><td>true - will reconnect immediately, and use the value set in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a85d76a82ad613088cd69742e3bde91b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setReconnectInterval </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interval value to use between reconnect attempts when the session is set to reconnect immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>value in milliseconds specifying the interval between reconnect attempts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf5c3f486f350ace2daaa7aaa5d08ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setSocketReceiveBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the inbound socket buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufSize</td><td>the size in bytes for the inbound buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bb91fd9a701ca087611f10a51742e55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setSocketSendBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the outbound socket buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufSize</td><td>the size in bytes for the outbound buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ae5794616924dacee6c4e5ef96c6115"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setSubHighWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the subscriber queue high watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>sets the subscriber high water mark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad61d26e6228a8c852e308865385428ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setSubLowWater </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the subscriber queue low watermark. </p>
<p>Each Nirvana subscriber uses a queue to store events retrieved from the server prior to performing the callback to the registered event listeners. When the queue reaches the high watermark the subscription is suspended to allow the event listener to catch up and control the amount of memory used on the client. When the queue reaches the low watermark, the subscription is automatically resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>the low water ,ark for the subscriber </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af193fba4557aaa37bbdcd8006ae1eea3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setSupportExtendedFiltering </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The client can enable / disable extended filtering *. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>- boolean flag indicating whether extended filtering is supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79224b58955b207a8ad5fce8012ef502"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setThreadReuseQueueSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the reusable threads pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the reusable threads pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e1355e9ffde4f566c32777ce759fcbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setTraceFolderLogSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> throws <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html">nIllegalArgumentException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the directory containing all trace log files. </p>
<p>Default value is 1GB. When this value is reached the UM client will go over the trace log folder and will delete the oldest zipped trace store log files (.zip). </p>
<p>Note : This value should be properly configured depending on the number of stores that are being traced and the store log size Effectively this value cannot be lower than (store log size * number of stores). e.g. if there are 500 stores and the store log size is 10MBs then value of this directory less than 5GB will not make sense and will not be taken into account because it can end up with case when all trace log files are close to 10MB but not yet zipped and therefore the cleaning strategy used will not be able to delete any files from the disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>of the directory for the trace log files in MBs throws <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html" title="This class defines the error that can be thrown by passing an illegal argument to any method of any c...">nIllegalArgumentException</a> in case the provided value is smaller than the size of single trace log file directory set via setTraceStoreLogSize or the provided value is out of range - min = 1024MB(1GB), max = 102400MB(100GB) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>10.5 </dd></dl>

</div>
</div>
<a class="anchor" id="aebb4b2c7dacffef040cfb0bc6e49503e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setTraceLoggerPath </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>logPath</em></td><td>)</td>
          <td> throws <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html">nIllegalArgumentException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Path to a location where per store logs will be stored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logPath</td><td>- the path where the store logs will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html" title="This class defines the error that can be thrown by passing an illegal argument to any method of any c...">nIllegalArgumentException</a></td><td>In case provided log path is null or empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>10.5 </dd></dl>

</div>
</div>
<a class="anchor" id="af6afcd4edb45e7a756764761e32b0734"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setTraceStoreLogLevel </td>
          <td>(</td>
          <td class="paramtype">StoreLogConfigLevel&#160;</td>
          <td class="paramname"><em>logLevel</em></td><td>)</td>
          <td> throws IllegalStateException</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the client store tracing log level. </p>
<p>Supported values: OFF, INFO, TRACE;</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>In case event store logging is disabled due to initialization failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>10.5 </dd></dl>

</div>
</div>
<a class="anchor" id="aaa6d43d2dbdbb1ee2b561891f80c0b70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setTraceStoreLogSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> throws <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html">nIllegalArgumentException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of a single per store log file. </p>
<p>Default value is 10MB. When this value is reached the UM client will rollover the trace log file and will zip the old one. Up to 100 files per store can be kept on the disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>of the log file in MBs </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_illegal_argument_exception.html" title="This class defines the error that can be thrown by passing an illegal argument to any method of any c...">nIllegalArgumentException</a></td><td>in case the provided value is bigger than the size of the trace log directory set via setTraceFolderLogSize or the provided value is out of range - min = 1MB, max = 100MB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>10.5 </dd></dl>

</div>
</div>
<a class="anchor" id="a2d69f07c52b9187331b7f71d5e53619a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setTraceStores </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>traceStores</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the list of stores(channels or queues) to be enabled for trace logging. </p>
<p>Valid options :</p>
<ul>
<li>wm/Group/myChannel; =&gt; specific store</li>
<li>* =&gt; all stores</li>
<li>*!a =&gt; all stores except specific one</li>
<li>wm/Group/ =&gt; all stores under specific folder</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traceStores</td><td>- String representing one of the above options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>10.5 </dd></dl>

</div>
</div>
<a class="anchor" id="a7be85c6d05489d3a6709509d2350e890"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void com.pcbsys.nirvana.client.nConstants.setWriteHandlerType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the client to specify the type of write handling that the client code will employ. </p>
<p>Please note this needs to be set prior to any <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html" title="This class represents a Nirvana session, the logical connection between the client API and the Nirvan...">nSession</a> creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>sStandardWriteHandler, sQueuedWriteHandler or sDirectWriteHandler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a3f716bb78bda8cd558004f678ac15e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boolean com.pcbsys.nirvana.client.nConstants.stripJMSMessageIdPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unused. </p>
<dl class="section return"><dt>Returns</dt><dd>false </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section since"><dt>Since</dt><dd>10.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a161e9079a8f626897978b475fb860d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final String com.pcbsys.nirvana.client.nConstants.HS_RELEASE_VERSION_PARAM = &quot;hsReleaseVersion&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional horizontal scalability url parameter which configures the Universal Messaging connection protocol version/release to use when connecting to a horizontal scalability group of servers. </p>
<p>If specified, the value must be formatted as <code>&lt;major&gt;.&lt;minor&gt;</code> where <code>major</code> and <code>minor</code> version components must be positive integers representing a valid Universal Messaging release version. </p>
<p>For example: </p>
<pre>(nsp://localhost:9000)(nsp://localhost:9001)?hsReleaseVersion=10.5</pre><p> In the above example, the client will try to connect to both Universal Messaging servers requesting a connection protocol version of <code>10.5</code>. If any of the server(s) does not support the configured version, connectivity to this server will not be established and it will not be available for user operations. However, while the horizontal scalability session is active (is not <a class="el" href="classcom_1_1pcbsys_1_1nirvana_1_1client_1_1n_session.html#af32556030a7639e24bc5b49ed92ed227">closed</a>, the session will continue retrying to connect to the target server in the background. </p>
<p>If this parameter is not specified for a horizontal scalability url, the session will validate that all servers have matching release versions (up to <code>major</code> and <code>minor</code> version components) and will fail initialization if the version of any of the server(s) are different. If some of the server(s) are not online on session initialization but are made available later after session is initialized, and negotiate a different Universal Messaging connection protocol version than the rest of the servers, the client will log an error message and close the session automatically. </p>

</div>
</div>
</div><!-- contents -->
</div> <!--
  ~
  ~   Copyright (c) 1999 - 2011 my-Channels Ltd
  ~   Copyright (c) 2012 - 2020 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.
  ~
  ~   Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
  ~
  --> <!-- end main -->
</div> <!-- end wrapper -->
<div id="footer">
<div>
Copyright &copy; 2020 Software AG, Darmstadt Germany
and/or Software AG USA, Inc., Reston, VA, United States of America,
and/or their licensors.
<br/>
</div>
</div> <!-- end footer -->
</body>
</html>
